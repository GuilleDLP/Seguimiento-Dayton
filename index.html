<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seguimiento de Clientes - University of Dayton Publishing</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <!-- Configuraci√≥n centralizada de base de datos -->
    <script src="./db-config.js" defer></script>
    <!-- Sistema de autenticaci√≥n -->
    <script src="./auth.js" defer></script>
    <!-- Configuraci√≥n de GitHub -->
    <script src="./github-config.js" defer></script>
    <!-- Sistema de sincronizaci√≥n GitHub -->
    <script src="./github-sync.js" defer></script>
    <!-- Panel de administrador -->
    <script src="./admin-panel.js" defer></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 16px;
            line-height: 1.5;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            position: relative;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title {
            text-align: left;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-info span {
            font-weight: 500;
            color: #ecf0f1;
        }
        
        .header h1 {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .header p {
            font-size: 16px;
            opacity: 0.9;
            font-weight: 400;
        }
        
        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e1e8ed;
        }
        
        .nav-tab {
            flex: 1;
            padding: 15px 20px;
            background: none;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #666;
        }
        
        .nav-tab.active {
            background: white;
            color: #2c3e50;
            border-bottom: 3px solid #667eea;
        }
        
        .nav-tab:hover:not(.active) {
            background: #e9ecef;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .form-container {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            transition: all 0.3s ease;
            background: white;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .input-error {
            border-color: #dc3545 !important;
            box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1) !important;
        }
        
        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .form-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        
        @media (max-width: 768px) {
            .form-row, .form-row-3 {
                grid-template-columns: 1fr;
            }
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-export {
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);
            color: white;
            margin-left: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn-export.csv {
            background: linear-gradient(135deg, #FFC107 0%, #FFEB3B 100%);
            color: #333;
        }

        .btn-export.pdf {
            background: linear-gradient(135deg, #F44336 0%, #E91E63 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            color: #212529;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 14px;
            margin: 0 2px;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .dashboard-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }
        
        .dashboard-card h3 {
            color: #2c3e50;
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .stat-number {
            font-size: 36px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .stat-label {
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .filtros-section {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .filtros-section h4 {
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .timeline-container {
            max-height: 600px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            padding: 20px;
        }

        .timeline-item {
            display: flex;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            position: relative;
        }

        .timeline-item.deleted {
            border-left: 4px solid #dc3545;
            background: #fff5f5;
            opacity: 0.7;
        }

        .timeline-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }
        
        .timeline-date {
            min-width: 120px;
            color: #7f8c8d;
            font-size: 14px;
            font-weight: 600;
        }
        
        .timeline-content {
            flex: 1;
            margin-left: 15px;
            margin-right: 120px;
        }
        
        .timeline-tipo {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .tipo-visita { background: #d4edda; color: #155724; }
        .tipo-llamada { background: #cce5ff; color: #004085; }
        .tipo-mensaje { background: #e8f5e8; color: #2e7d32; }
        .tipo-email { background: #fff3cd; color: #856404; }
        .tipo-capacitacion { background: #f8d7da; color: #721c24; }
        .tipo-seguimiento { background: #e2e3e5; color: #383d41; }
        .tipo-sesion { background: #fff8e1; color: #f57f17; }
        .tipo-presentacion { background: #d1ecf1; color: #0c5460; }
                
        .timeline-cliente {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .timeline-descripcion {
            color: #555;
            line-height: 1.4;
        }

        .trash-controls {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #ffeaa7;
        }

        .trash-controls h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .trash-item {
            display: flex;
            margin-bottom: 15px;
            padding: 12px;
            background: #fff5f5;
            border-radius: 6px;
            border-left: 3px solid #dc3545;
            position: relative;
        }

        .trash-date {
            min-width: 100px;
            color: #dc3545;
            font-size: 12px;
            font-weight: 600;
        }

        .trash-content {
            flex: 1;
            margin-left: 10px;
            margin-right: 100px;
        }

        .trash-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 3px;
        }

        .trash-cliente {
            font-weight: 600;
            color: #721c24;
            font-size: 14px;
            margin-bottom: 3px;
        }

        .trash-descripcion {
            color: #666;
            font-size: 12px;
            line-height: 1.3;
        }
        
        .no-data {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #e1e8ed;
            font-style: italic;
        }
        
        .message {
            padding: 12px 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 16px;
            font-weight: 500;
            display: none;
        }
        
        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .busqueda-rapida {
            position: relative;
            margin-bottom: 20px;
        }
        
        .busqueda-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            font-size: 18px;
            border: 2px solid #e1e8ed;
            border-radius: 25px;
            background: white;
        }
        
        .busqueda-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #7f8c8d;
            font-size: 18px;
        }
        
        .cliente-resultado {
            background: white;
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }
        
        .cliente-resultado:hover {
            background: #f0f8ff;
            transform: translateX(5px);
        }
        
        .cliente-nombre {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .cliente-info {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 10px;
        }
        
        .cliente-stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .stat-badge {
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #495057;
        }

        .footer-leyenda {
            margin-top: 50px;
            padding: 15px;
            text-align: center;
            font-size: 12px;
            color: #555;
            background-color: #f1f1f1;
            font-style: italic;
            border-top: 1px solid #ddd;
        }

        .validation-error {
            color: #dc3545;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }

        .export-buttons-container {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e1e8ed;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 200px;
        }

        .button-group h4 {
            margin: 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
            padding-bottom: 10px;
            border-bottom: 2px solid #e1e8ed;
            width: 100%;
            text-align: center;
        }

        .button-group .btn-export,
        .button-group .btn-sync {
            margin: 5px;
            min-width: 160px;
        }

        .btn-sync {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            position: relative;
            overflow: hidden;
        }

        .btn-sync:hover {
            background: linear-gradient(135deg, #138496 0%, #117a8b 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(23, 162, 184, 0.3);
        }

        .btn-sync:active {
            transform: translateY(0);
        }

        .btn-sync:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-sync.syncing {
            background: #ffc107;
            cursor: wait;
        }

        .btn-sync.syncing::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 10px;
            width: 16px;
            height: 16px;
            margin-top: -8px;
            border: 2px solid transparent;
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .export-buttons-container {
                flex-direction: column;
                gap: 15px;
            }

            .button-group {
                min-width: 100%;
            }
        }

        .bulk-actions {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .bulk-actions h4 {
            color: #721c24;
            margin-bottom: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e1e8ed;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            text-align: right;
        }

        .modal-footer button {
            margin-left: 10px;
        }

    </style>
    <!-- SheetJS (XLSX) -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <!-- jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- jsPDF-AutoTable (for easy table generation in PDF) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-title">
                    <h1>Seguimiento de Clientes</h1>
                    <p>University of Dayton Publishing - Sistema de Registro Anual</p>
                </div>
                <div id="userInfo" class="user-info" style="display: none;"></div>
            </div>
        </div>
        
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="cambiarTab(event, 'dashboard')">üìä Dashboard</button>
            <button class="nav-tab" onclick="cambiarTab(event, 'registro')">‚ûï Nuevo Registro</button>
            <button class="nav-tab" onclick="cambiarTab(event, 'timeline')">üìÖ Timeline</button>
            <button class="nav-tab" onclick="cambiarTab(event, 'clientes')">üë• Clientes</button>
            <button class="nav-tab" onclick="cambiarTab(event, 'papelera')">üóëÔ∏è Papelera</button>
        </div>

        <!-- TAB: DASHBOARD -->
        <div id="dashboard" class="tab-content active">
            <div id="messages"></div>
             <div class="dashboard-grid">
                <div class="dashboard-card">
                    <h3>üìà Actividad Total</h3>
                    <div class="stat-number" id="totalActividades">0</div>
                    <div class="stat-label">Interacciones registradas</div>
                </div>
                <div class="dashboard-card">
                    <h3>üè´ Clientes Activos</h3>
                    <div class="stat-number" id="clientesActivos">0</div>
                    <div class="stat-label">Colegios con actividad</div>
                </div>
                <div class="dashboard-card">
                    <h3>üìû Este Mes</h3>
                    <div class="stat-number" id="actividadMes">0</div>
                    <div class="stat-label" id="labelMesActual">Interacciones en...</div>
                </div>
                <div class="dashboard-card">
                    <h3>üéØ M√°s Activa</h3>
                    <div class="stat-number" id="gerenciaMasActiva">-</div>
                    <div class="stat-label">Gerencia con m√°s actividad</div>
                </div>
                <div class="dashboard-card">
                    <h3>üóëÔ∏è En Papelera</h3>
                    <div class="stat-number" id="itemsEnPapelera">0</div>
                    <div class="stat-label">Registros eliminados</div>
                </div>
            </div>
            <div class="filtros-section">
                <h4>üìä Resumen por Gerencia</h4>
                <div id="resumenGerencias" class="dashboard-grid"></div>
            </div>
            <div class="filtros-section">
                <h4>üóìÔ∏è Filtrar por Fecha para Exportaci√≥n</h4>
                <div class="form-row">
                    <div>
                        <label for="dashboardFechaDesde">Desde:</label>
                        <input type="date" id="dashboardFechaDesde" onchange="actualizarDashboard()">
                    </div>
                    <div>
                        <label for="dashboardFechaHasta">Hasta:</label>
                        <input type="date" id="dashboardFechaHasta" onchange="actualizarDashboard()">
                    </div>
                </div>
            </div>
            <div class="bulk-actions">
                <h4>‚ö†Ô∏è Acciones de Administraci√≥n</h4>
                <button class="btn-danger btn-small" onclick="confirmarLimpiezaTotal()">
                    üßπ Limpiar Toda la Base de Datos
                </button>
                <button class="btn-warning btn-small" onclick="confirmarVaciarPapelera()">
                    üóëÔ∏è Vaciar Papelera Permanentemente
                </button>
            </div>
            <div id="dashboardExportButtons" class="export-buttons-container">
                <!-- Buttons will be injected here by JS -->
            </div>
        </div>

        <!-- TAB: NUEVO REGISTRO -->
        <div id="registro" class="tab-content">
            <div class="form-container">
                <h3 style="margin-bottom: 20px; color: #2c3e50;">‚ûï Registrar Nueva Interacci√≥n</h3>
                <form id="registroForm">
                    <div class="form-row-3">
                        <div class="form-group">
                            <label for="fecha">Fecha</label>
                            <input type="date" id="fecha" name="fecha" required>
                            <div class="validation-error" id="error-fecha"></div>
                        </div>
                        <div class="form-group">
                            <label for="tipoInteraccion">Tipo de Interacci√≥n</label>
                            <select id="tipoInteraccion" name="tipoInteraccion" required>
                                <option value="">Seleccionar tipo</option>
                                <option value="visita">üè´ Visita</option>
                                <option value="llamada">üìû Llamada</option>
                                <option value="mensaje">üí¨ Mensaje</option>
                                <option value="email">üìß Email</option>
                                <option value="capacitacion">üéì Capacitaci√≥n</option>
                                <option value="seguimiento">üìù Seguimiento</option>
                                <option value="sesion">üë®‚Äçüè´ Sesi√≥n Acad√©mica</option>
                                <option value="presentacion">üìã Presentaci√≥n</option>
                            </select>
                            <div class="validation-error" id="error-tipoInteraccion"></div>
                        </div>
                        <div class="form-group">
                            <label for="consultor">Consultor/a</label>
                            <select id="consultor" name="consultor" required>
                                <option value="">Seleccionar consultor</option>
                                <!-- Las opciones se cargan din√°micamente desde los usuarios del sistema -->
                            </select>
                            <div class="validation-error" id="error-consultor"></div>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="gerenciaReg">Gerencia</label>
                            <select id="gerenciaReg" name="gerenciaReg" required onchange="actualizarZonasRegistro()">
                                <option value="">Seleccionar gerencia</option>
                                <option value="Baj√≠o">Baj√≠o</option>
                                <option value="Centro-Norte">Centro-Norte</option>
                                <option value="Centro-Sur">Centro-Sur</option>
                                <option value="Norte">Norte</option>
                                <option value="Occidente">Occidente</option>
                                <option value="Oriente">Oriente</option>
                                <option value="Pac√≠fico">Pac√≠fico</option>
                                <option value="Sur">Sur</option>
                            </select>
                            <div class="validation-error" id="error-gerenciaReg"></div>
                        </div>
                        <div class="form-group">
                            <label for="zonaReg">Zona Comercial</label>
                            <select id="zonaReg" name="zonaReg" required>
                                <option value="">Primero selecciona una gerencia</option>
                            </select>
                            <div class="validation-error" id="error-zonaReg"></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="cliente">Colegio/Cliente</label>
                        <input type="text" id="cliente" name="cliente" required placeholder="Nombre del colegio o instituci√≥n" list="clientesDatalist" autocomplete="off">
                        <datalist id="clientesDatalist"></datalist>
                        <div class="validation-error" id="error-cliente"></div>
                    </div>
                    <div class="form-group">
                        <label for="descripcion">Descripci√≥n de la Interacci√≥n</label>
                        <textarea id="descripcion" name="descripcion" required placeholder="Describe qu√© se hizo, qu√© se acord√≥, pr√≥ximos pasos..."></textarea>
                        <div class="validation-error" id="error-descripcion"></div>
                    </div>
                    <div style="text-align: center; margin-top: 25px;">
                        <button type="button" class="btn-primary" onclick="guardarRegistro()">
                            üíæ Guardar Registro
                        </button>
                        <button type="button" class="btn-secondary" onclick="limpiarFormulario()">
                            üÜï Limpiar
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- TAB: TIMELINE -->
        <div id="timeline" class="tab-content">
            <div class="filtros-section">
                <h4>üîç Filtrar Timeline</h4>
                <div class="form-row-3">
                    <div>
                        <label for="filtroGerencia">Gerencia:</label>
                        <select id="filtroGerencia" onchange="filtrarTimeline()">
                            <option value="">Todas las gerencias</option>
                            <option value="Baj√≠o">Baj√≠o</option>
                            <option value="Centro-Norte">Centro-Norte</option>
                            <option value="Centro-Sur">Centro-Sur</option>
                            <option value="Norte">Norte</option>
                            <option value="Occidente">Occidente</option>
                            <option value="Oriente">Oriente</option>
                            <option value="Pac√≠fico">Pac√≠fico</option>
                            <option value="Sur">Sur</option>
                        </select>
                    </div>
                    <div>
                        <label for="filtroTipo">Tipo:</label>
                        <select id="filtroTipo" onchange="filtrarTimeline()">
                            <option value="">Todos los tipos</option>
                            <option value="visita">üè´ Visitas</option>
                            <option value="llamada">üìû Llamadas</option>
                            <option value="mensaje">üí¨ Mensaje</option>
                            <option value="email">üìß Emails</option>
                            <option value="capacitacion">üéì Capacitaciones</option>
                            <option value="seguimiento">üìù Seguimientos</option>
                            <option value="sesion">üë®‚Äçüè´ Sesiones Acad√©micas</option>
                            <option value="presentacion">üìã Presentaciones</option>
                        </select>
                    </div>
                    <div>
                        <label for="filtroConsultor">Consultor:</label>
                        <select id="filtroConsultor" onchange="filtrarTimeline()">
                            <option value="">Todos los consultores</option>
                            <!-- Las opciones se cargan din√°micamente desde los usuarios del sistema -->
                        </select>
                    </div>
                </div>
                <div class="form-row" style="margin-top: 15px;">
                    <div>
                        <label for="fechaDesde">Desde:</label>
                        <input type="date" id="fechaDesde" onchange="filtrarTimeline()">
                    </div>
                    <div>
                        <label for="fechaHasta">Hasta:</label>
                        <input type="date" id="fechaHasta" onchange="filtrarTimeline()">
                    </div>
                </div>
            </div>
            <div class="bulk-actions">
                <h4>üóëÔ∏è Eliminaci√≥n Masiva</h4>
                <p style="margin-bottom: 10px;">Eliminar todos los registros que coincidan con los filtros actuales:</p>
                <button class="btn-danger btn-small" onclick="confirmarEliminacionMasiva()">
                    üóëÔ∏è Eliminar Registros Filtrados
                </button>
                <small style="display: block; margin-top: 5px; color: #666;">‚ö†Ô∏è Esta acci√≥n mover√° los registros a la papelera</small>
            </div>
            <div class="timeline-container" id="timelineContainer">
                <div class="no-data">
                    üìÖ No hay registros para mostrar. ¬°Comienza agregando algunas interacciones!
                </div>
            </div>
            <div id="timelineExportButtons" class="export-buttons-container">
                <!-- Buttons will be injected here by JS -->
            </div>
        </div>

        <!-- TAB: CLIENTES -->
        <div id="clientes" class="tab-content">
            <div class="busqueda-rapida">
                <input type="text" class="busqueda-input" id="busquedaClientes" 
                       placeholder="Buscar clientes por nombre, gerencia o zona..."
                       oninput="buscarClientes()">
                <span class="busqueda-icon">üîç</span>
            </div>
            <div id="clientesContainer">
                <div class="no-data">
                    üë• A√∫n no hay clientes registrados. ¬°Agrega algunas interacciones para empezar!
                </div>
            </div>
        </div>

        <!-- TAB: PAPELERA -->
        <div id="papelera" class="tab-content">
            <div class="trash-controls">
                <h4>üóëÔ∏è Papelera de Reciclaje</h4>
                <p>Los registros eliminados se mantienen aqu√≠ por seguridad. Puedes restaurarlos o eliminarlos permanentemente.</p>
                <div style="margin-top: 10px;">
                    <button class="btn-success btn-small" onclick="restaurarTodos()">
                        ‚Ü©Ô∏è Restaurar Todos
                    </button>
                    <button class="btn-danger btn-small" onclick="confirmarVaciarPapelera()">
                        üóëÔ∏è Vaciar Papelera
                    </button>
                </div>
            </div>
            <div class="timeline-container" id="papeleraContainer">
                <div class="no-data">
                    üóëÔ∏è La papelera est√° vac√≠a.
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Confirmaci√≥n -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Confirmar Acci√≥n</h3>
                <button class="modal-close" onclick="cerrarModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="modalMessage">¬øEst√°s seguro de que deseas realizar esta acci√≥n?</p>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="cerrarModal()">Cancelar</button>
                <button class="btn-danger" id="confirmButton" onclick="ejecutarAccionConfirmada()">Confirmar</button>
            </div>
        </div>
    </div>

    <footer class="footer-leyenda">
        Herramienta de uso interno. Propiedad de <strong>University of Dayton Publishing</strong>. Su uso est√° restringido exclusivamente al personal autorizado.
    </footer>

    <script>
        // =================================================================
        // CONFIGURACI√ìN DE INDEXEDDB CON MANEJO ROBUSTO DE ERRORES
        // =================================================================
        // NOTA: Las constantes DB_NAME, DB_VERSION, etc. ahora vienen de db-config.js
        // Esto garantiza consistencia entre todos los archivos
        let db;
        let dbStatus = 'offline';
        let memoryFallback = []; // Fallback para cuando IndexedDB falle
        let trashFallback = []; // Fallback para papelera

        // Configuraci√≥n de zona por gerencia con validaci√≥n
        const zonasPorGerencia = {
            'Baj√≠o': ['Celaya', 'Irapuato', 'Le√≥n I', 'Le√≥n II', 'Morelia I', 'Morelia II', 'Quer√©taro I', 'Quer√©taro II', 'San Luis Potos√≠ I', 'San Luis Potos√≠ II'],
            'Centro-Norte': ['Atizap√°n', 'Cuautitl√°n', 'Ecatepec', 'Gustavo A. Madero', 'Naucalpan', 'Neza', 'Tlalnepantla', 'Toluca', 'Tultitl√°n', 'Xochimilco'],
            'Centro-Sur': ['Acapulco', '√Ålvaro Obreg√≥n', 'Azcapotzalco', 'Coyoac√°n', 'Cuautla', 'Cuernavaca', 'Iztapalapa I', 'Iztapalapa II', 'Miguel Hidalgo', 'Tlalpan'],
            'Norte': ['Chihuahua', 'Cd. Ju√°rez', 'Durango', 'Monterrey I', 'Monterrey II', 'Monterrey III', 'Monterrey IV', 'Reynosa', 'Saltillo', 'Tampico', 'Torre√≥n'],
            'Occidente': ['Aguascalientes', 'Colima', 'Guadalajara I', 'Guadalajara II', 'Tepic', 'Tlajomulco', 'Tlaquepaque', 'Zapopan I', 'Zapopan II'],
            'Oriente': ['Chalco', 'Oaxaca I', 'Oaxaca II', 'Pachuca', 'Puebla I', 'Puebla II', 'Puebla III', 'Texcoco', 'Tulancingo'],
            'Pac√≠fico': ['Cd. Obreg√≥n', 'Culiac√°n', 'Hermosillo I', 'Hermosillo II', 'Los Cabos', 'Mazatl√°n', 'Mexicali', 'Tijuana I', 'Tijuana II'],
            'Sur': ['Canc√∫n', 'C√≥rdoba', 'M√©rida I', 'M√©rida II', 'Playa del Carmen', 'Poza Rica', 'Tapachula', 'Tuxtla', 'Veracruz I', 'Veracruz II', 'Villahermosa I', 'Villahermosa II']
        };

        let registrosOriginales = [];
        let registrosEliminados = [];
        let accionPendiente = null; // Para manejar confirmaciones

        // =================================================================
        // FUNCIONES AUXILIARES PARA VALIDACI√ìN Y SANITIZACI√ìN
        // =================================================================
        function sanitizeString(str) {
            if (!str || typeof str !== 'string') return '';
            return str.trim();
        }

        function safeGet(obj, key, defaultValue = '') {
            if (!obj || typeof obj !== 'object') return defaultValue;
            return obj[key] || defaultValue;
        }

        function validateGerenciaZona(gerencia, zona) {
            console.log(`üîç Validando gerencia: "${gerencia}", zona: "${zona}"`);
            
            if (!gerencia || !zona) {
                console.log('‚ùå Gerencia o zona vac√≠as');
                return false;
            }
            
            const zonasValidas = zonasPorGerencia[gerencia];
            if (!zonasValidas) {
                console.log(`‚ùå Gerencia "${gerencia}" no existe`);
                return false;
            }
            
            const isValid = zonasValidas.includes(zona);
            console.log(`${isValid ? '‚úÖ' : '‚ùå'} Zona "${zona}" ${isValid ? 'v√°lida' : 'inv√°lida'} para gerencia "${gerencia}"`);
            return isValid;
        }

        function showValidationError(fieldId, message) {
            const field = document.getElementById(fieldId);
            const errorDiv = document.getElementById(`error-${fieldId}`);
            
            if (field) field.classList.add('input-error');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }

        function clearValidationError(fieldId) {
            const field = document.getElementById(fieldId);
            const errorDiv = document.getElementById(`error-${fieldId}`);
            
            if (field) field.classList.remove('input-error');
            if (errorDiv) {
                errorDiv.textContent = '';
                errorDiv.style.display = 'none';
            }
        }

        function clearAllValidationErrors() {
            const errorFields = ['fecha', 'tipoInteraccion', 'consultor', 'gerenciaReg', 'zonaReg', 'cliente', 'descripcion'];
            errorFields.forEach(clearValidationError);
        }

        function updateDBStatus(status) {
            dbStatus = status;
            const statusEl = document.getElementById('dbStatus');
            if (statusEl) {
                statusEl.className = `db-status ${status}`;
                statusEl.textContent = status === 'online' ? 'üü¢ BD Conectada' : 'üî¥ BD Desconectada';
            }
            console.log(`üìä Estado de BD actualizado: ${status}`);
        }

        // =================================================================
        // INICIALIZACI√ìN DE INDEXEDDB CON MANEJO ROBUSTO DE ERRORES
        // =================================================================
        async function initDB() {
            return new Promise((resolve, reject) => {
                console.log('üîÑ Iniciando conexi√≥n a IndexedDB...');
                
                if (!window.indexedDB) {
                    console.error('‚ùå IndexedDB no soportado en este navegador');
                    updateDBStatus('offline');
                    reject('IndexedDB no soportado');
                    return;
                }

                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    const error = event.target.error;
                    console.error('‚ùå Error al abrir IndexedDB:', error);
                    updateDBStatus('offline');
                    
                    let errorMessage = 'üî¥ Error en la base de datos: ';
                    if (error.name === 'QuotaExceededError') {
                        errorMessage += 'Espacio de almacenamiento agotado. Libera espacio en tu navegador.';
                    } else if (error.name === 'InvalidStateError') {
                        errorMessage += 'Base de datos en estado inv√°lido. Reinicia el navegador.';
                    } else if (error.name === 'VersionError') {
                        errorMessage += 'Conflicto de versi√≥n de BD. Recarga la p√°gina.';
                    } else {
                        errorMessage += `${error.name || 'Error desconocido'}. Usando modo fallback.`;
                    }
                    
                    mostrarMensaje(errorMessage, 'error');
                    reject(errorMessage);
                };

                request.onblocked = (event) => {
                    console.warn('‚ö†Ô∏è IndexedDB bloqueada. Otra pesta√±a puede estar usando la BD.');
                    mostrarMensaje('‚ö†Ô∏è Base de datos ocupada. Cierra otras pesta√±as de esta aplicaci√≥n.', 'warning');
                };

                request.onupgradeneeded = (event) => {
                    console.log('üîß Actualizando estructura de BD...');
                    const db = event.target.result;
                    
                    try {
                        // Store principal de registros
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                            objectStore.createIndex('fecha', 'fecha', { unique: false });
                            objectStore.createIndex('gerencia', 'gerencia', { unique: false });
                            objectStore.createIndex('consultor', 'consultor', { unique: false });
                            objectStore.createIndex('cliente', 'cliente', { unique: false });
                            console.log('‚úÖ Object store de registros creado');
                        }

                        // Store de papelera
                        if (!db.objectStoreNames.contains(TRASH_STORE_NAME)) {
                            const trashStore = db.createObjectStore(TRASH_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                            trashStore.createIndex('fechaEliminacion', 'fechaEliminacion', { unique: false });
                            trashStore.createIndex('originalId', 'originalId', { unique: false });
                            console.log('‚úÖ Object store de papelera creado');
                        }

                        console.log('‚úÖ Estructura de BD actualizada exitosamente');
                    } catch (upgradeError) {
                        console.error('‚ùå Error durante actualizaci√≥n de BD:', upgradeError);
                        throw upgradeError;
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('‚úÖ IndexedDB conectada exitosamente');
                    updateDBStatus('online');
                    
                    // Manejar errores de conexi√≥n perdida
                    db.onerror = (errorEvent) => {
                        console.error('‚ùå Error de BD en tiempo de ejecuci√≥n:', errorEvent.target.error);
                        updateDBStatus('offline');
                    };
                    
                    db.onversionchange = () => {
                        console.warn('‚ö†Ô∏è Otra pesta√±a est√° actualizando la BD');
                        db.close();
                        updateDBStatus('offline');
                        mostrarMensaje('‚ö†Ô∏è Base de datos actualizada en otra pesta√±a. Recarga esta p√°gina.', 'warning');
                    };
                    
                    resolve(db);
                };
            });
        }

        // =================================================================
        // FUNCIONES DE BASE DE DATOS MEJORADAS
        // =================================================================
        async function addRegistroToDB(registro) {
            return new Promise(async (resolve, reject) => {
                console.log('üíæ Guardando registro en BD...', registro);
                
                if (dbStatus === 'offline' || !db) {
                    console.log('üì± BD offline, usando memoria como fallback');
                    registro.id = Date.now(); // ID temporal
                    memoryFallback.push(registro);
                    resolve(registro.id);
                    return;
                }

                let retryCount = 0;
                const maxRetries = 3;

                const tryAdd = () => {
                    try {
                        const transaction = db.transaction([STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        const request = store.add(registro);
                        
                        request.onsuccess = () => {
                            console.log('‚úÖ Registro guardado en BD con ID:', request.result);
                            resolve(request.result);
                        };
                        
                        request.onerror = (event) => {
                            const error = event.target.error;
                            console.error(`‚ùå Error al guardar (intento ${retryCount + 1}):`, error);
                            
                            if (retryCount < maxRetries && error.name !== 'ConstraintError') {
                                retryCount++;
                                console.log(`üîÑ Reintentando guardar... (${retryCount}/${maxRetries})`);
                                setTimeout(tryAdd, 1000 * retryCount);
                            } else {
                                console.log('üì± Guardando en memoria como fallback');
                                registro.id = Date.now();
                                memoryFallback.push(registro);
                                updateDBStatus('offline');
                                resolve(registro.id);
                            }
                        };

                        transaction.onerror = (event) => {
                            console.error('‚ùå Error de transacci√≥n:', event.target.error);
                            if (retryCount < maxRetries) {
                                retryCount++;
                                setTimeout(tryAdd, 1000 * retryCount);
                            } else {
                                registro.id = Date.now();
                                memoryFallback.push(registro);
                                resolve(registro.id);
                            }
                        };

                    } catch (syncError) {
                        console.error('‚ùå Error sincr√≥nico al guardar:', syncError);
                        registro.id = Date.now();
                        memoryFallback.push(registro);
                        resolve(registro.id);
                    }
                };

                tryAdd();
            });
        }

        async function getAllRegistrosFromDB() {
            return new Promise(async (resolve, reject) => {
                console.log('üìñ Cargando registros desde BD...');
                
                if (dbStatus === 'offline' || !db) {
                    console.log('üì± BD offline, usando datos de memoria');
                    resolve([...memoryFallback]);
                    return;
                }

                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const dbRecords = request.result || [];
                        const allRecords = [...dbRecords, ...memoryFallback];
                        console.log(`‚úÖ Cargados ${dbRecords.length} registros de BD + ${memoryFallback.length} de memoria`);
                        resolve(allRecords);
                    };

                    request.onerror = (event) => {
                        console.error('‚ùå Error al cargar registros:', event.target.error);
                        console.log('üì± Usando solo datos de memoria');
                        resolve([...memoryFallback]);
                    };

                    transaction.onerror = (event) => {
                        console.error('‚ùå Error de transacci√≥n al cargar:', event.target.error);
                        resolve([...memoryFallback]);
                    };

                } catch (syncError) {
                    console.error('‚ùå Error sincr√≥nico al cargar:', syncError);
                    resolve([...memoryFallback]);
                }
            });
        }

        async function deleteRegistroFromDB(id) {
            return new Promise(async (resolve, reject) => {
                console.log('üóëÔ∏è Eliminando registro ID:', id);
                
                // Primero buscamos el registro
                const registro = registrosOriginales.find(r => r.id === id);
                if (!registro) {
                    console.error('‚ùå Registro no encontrado:', id);
                    reject('Registro no encontrado');
                    return;
                }

                // Mover a papelera
                const registroEliminado = {
                    ...registro,
                    originalId: id,
                    fechaEliminacion: obtenerFechaHoyLocal()
                };

                try {
                    // Agregar a papelera
                    await addToTrash(registroEliminado);
                    
                    if (dbStatus === 'offline' || !db) {
                        // Eliminar de memoria fallback
                        const index = memoryFallback.findIndex(r => r.id === id);
                        if (index > -1) {
                            memoryFallback.splice(index, 1);
                            console.log('‚úÖ Registro eliminado de memoria fallback');
                        }
                        resolve(true);
                        return;
                    }

                    // Eliminar de IndexedDB
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.delete(id);

                    request.onsuccess = () => {
                        console.log('‚úÖ Registro eliminado de BD y movido a papelera');
                        resolve(true);
                    };

                    request.onerror = (event) => {
                        console.error('‚ùå Error eliminando de BD:', event.target.error);
                        reject(event.target.error);
                    };

                } catch (error) {
                    console.error('‚ùå Error moviendo a papelera:', error);
                    reject(error);
                }
            });
        }

        async function addToTrash(registroEliminado) {
            return new Promise(async (resolve, reject) => {
                console.log('üóëÔ∏è Moviendo a papelera:', registroEliminado);
                
                if (dbStatus === 'offline' || !db) {
                    registroEliminado.id = Date.now();
                    trashFallback.push(registroEliminado);
                    resolve(registroEliminado.id);
                    return;
                }

                try {
                    const transaction = db.transaction([TRASH_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(TRASH_STORE_NAME);
                    const request = store.add(registroEliminado);

                    request.onsuccess = () => {
                        console.log('‚úÖ Registro agregado a papelera con ID:', request.result);
                        resolve(request.result);
                    };

                    request.onerror = (event) => {
                        console.error('‚ùå Error agregando a papelera:', event.target.error);
                        registroEliminado.id = Date.now();
                        trashFallback.push(registroEliminado);
                        resolve(registroEliminado.id);
                    };

                } catch (error) {
                    console.error('‚ùå Error sincr√≥nico agregando a papelera:', error);
                    registroEliminado.id = Date.now();
                    trashFallback.push(registroEliminado);
                    resolve(registroEliminado.id);
                }
            });
        }

        async function getAllTrashFromDB() {
            return new Promise(async (resolve, reject) => {
                console.log('üìñ Cargando registros de papelera...');
                
                if (dbStatus === 'offline' || !db) {
                    resolve([...trashFallback]);
                    return;
                }

                try {
                    const transaction = db.transaction([TRASH_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(TRASH_STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const dbRecords = request.result || [];
                        const allRecords = [...dbRecords, ...trashFallback];
                        console.log(`‚úÖ Cargados ${dbRecords.length} registros de papelera BD + ${trashFallback.length} de memoria`);
                        resolve(allRecords);
                    };

                    request.onerror = (event) => {
                        console.error('‚ùå Error cargando papelera:', event.target.error);
                        resolve([...trashFallback]);
                    };

                } catch (error) {
                    console.error('‚ùå Error sincr√≥nico cargando papelera:', error);
                    resolve([...trashFallback]);
                }
            });
        }

        async function restoreFromTrash(trashId, originalId) {
            return new Promise(async (resolve, reject) => {
                console.log('‚Ü©Ô∏è Restaurando registro de papelera:', trashId, 'Original ID:', originalId);
                
                // Buscar en papelera
                const trashRecord = registrosEliminados.find(r => r.id === trashId);
                if (!trashRecord) {
                    reject('Registro no encontrado en papelera');
                    return;
                }

                // Crear registro restaurado
                const restoredRecord = { ...trashRecord };
                delete restoredRecord.originalId;
                delete restoredRecord.fechaEliminacion;
                delete restoredRecord.id; // Para que se asigne nuevo ID

                try {
                    // Agregar de vuelta a registros
                    const newId = await addRegistroToDB(restoredRecord);
                    
                    // Eliminar de papelera
                    await deleteFromTrash(trashId);
                    
                    console.log('‚úÖ Registro restaurado con nuevo ID:', newId);
                    resolve(newId);

                } catch (error) {
                    console.error('‚ùå Error restaurando registro:', error);
                    reject(error);
                }
            });
        }

        async function deleteFromTrash(trashId) {
            return new Promise(async (resolve, reject) => {
                console.log('üóëÔ∏è Eliminando permanentemente de papelera:', trashId);
                
                if (dbStatus === 'offline' || !db) {
                    const index = trashFallback.findIndex(r => r.id === trashId);
                    if (index > -1) {
                        trashFallback.splice(index, 1);
                    }
                    resolve(true);
                    return;
                }

                try {
                    const transaction = db.transaction([TRASH_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(TRASH_STORE_NAME);
                    const request = store.delete(trashId);

                    request.onsuccess = () => {
                        console.log('‚úÖ Registro eliminado permanentemente de papelera');
                        resolve(true);
                    };

                    request.onerror = (event) => {
                        console.error('‚ùå Error eliminando de papelera:', event.target.error);
                        reject(event.target.error);
                    };

                } catch (error) {
                    console.error('‚ùå Error sincr√≥nico eliminando de papelera:', error);
                    reject(error);
                }
            });
        }
        
        // =================================================================
        // FUNCIONES DE ELIMINACI√ìN Y CONFIRMACI√ìN
        // =================================================================
        function mostrarModal(titulo, mensaje, accion) {
            const modal = document.getElementById('confirmModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            
            modalTitle.textContent = titulo;
            modalMessage.textContent = mensaje;
            accionPendiente = accion;
            
            modal.style.display = 'block';
        }

        function cerrarModal() {
            const modal = document.getElementById('confirmModal');
            modal.style.display = 'none';
            accionPendiente = null;
        }

        async function ejecutarAccionConfirmada() {
            if (accionPendiente) {
                await accionPendiente();
                accionPendiente = null;
            }
            cerrarModal();
        }

        async function eliminarRegistro(id) {
            try {
                await deleteRegistroFromDB(id);
                mostrarMensaje('‚úÖ Registro movido a la papelera exitosamente', 'success');
                await cargarDatosYActualizarUI();
            } catch (error) {
                console.error('‚ùå Error eliminando registro:', error);
                mostrarMensaje('üî¥ Error eliminando el registro', 'error');
            }
        }

        function confirmarEliminacion(id, nombreCliente) {
            mostrarModal(
                'üóëÔ∏è Confirmar Eliminaci√≥n',
                `¬øEst√°s seguro de que deseas eliminar el registro de "${nombreCliente}"? Se mover√° a la papelera y podr√°s restaurarlo despu√©s.`,
                () => eliminarRegistro(id)
            );
        }

        async function eliminarRegistrosFiltrados() {
            const registrosFiltrados = getFilteredDataForExport('timeline');
            
            if (registrosFiltrados.length === 0) {
                mostrarMensaje('‚ö†Ô∏è No hay registros para eliminar con los filtros actuales', 'warning');
                return;
            }

            try {
                let eliminados = 0;
                let errores = 0;

                for (const registro of registrosFiltrados) {
                    try {
                        await deleteRegistroFromDB(registro.id);
                        eliminados++;
                    } catch (error) {
                        console.error('‚ùå Error eliminando registro:', registro.id, error);
                        errores++;
                    }
                }

                mostrarMensaje(`‚úÖ ${eliminados} registros movidos a la papelera. ${errores > 0 ? `${errores} errores.` : ''}`, eliminados > 0 ? 'success' : 'warning');
                await cargarDatosYActualizarUI();

            } catch (error) {
                console.error('‚ùå Error en eliminaci√≥n masiva:', error);
                mostrarMensaje('üî¥ Error en la eliminaci√≥n masiva', 'error');
            }
        }

        function confirmarEliminacionMasiva() {
            const registrosFiltrados = getFilteredDataForExport('timeline');
            mostrarModal(
                'üóëÔ∏è Confirmar Eliminaci√≥n Masiva',
                `¬øEst√°s seguro de que deseas eliminar ${registrosFiltrados.length} registros que coinciden con los filtros actuales? Se mover√°n a la papelera.`,
                eliminarRegistrosFiltrados
            );
        }

        async function restaurarRegistro(trashId, originalId, nombreCliente) {
            try {
                await restoreFromTrash(trashId, originalId);
                mostrarMensaje(`‚úÖ Registro de "${nombreCliente}" restaurado exitosamente`, 'success');
                await cargarDatosYActualizarUI();
            } catch (error) {
                console.error('‚ùå Error restaurando registro:', error);
                mostrarMensaje('üî¥ Error restaurando el registro', 'error');
            }
        }

        async function eliminarPermanentemente(trashId, nombreCliente) {
            try {
                await deleteFromTrash(trashId);
                mostrarMensaje(`‚úÖ Registro de "${nombreCliente}" eliminado permanentemente`, 'success');
                await cargarDatosYActualizarUI();
            } catch (error) {
                console.error('‚ùå Error eliminando permanentemente:', error);
                mostrarMensaje('üî¥ Error eliminando permanentemente', 'error');
            }
        }

        function confirmarEliminacionPermanente(trashId, nombreCliente) {
            mostrarModal(
                '‚ö†Ô∏è Confirmar Eliminaci√≥n Permanente',
                `¬øEst√°s seguro de que deseas eliminar PERMANENTEMENTE el registro de "${nombreCliente}"? Esta acci√≥n NO se puede deshacer.`,
                () => eliminarPermanentemente(trashId, nombreCliente)
            );
        }

        async function restaurarTodos() {
            if (registrosEliminados.length === 0) {
                mostrarMensaje('‚ö†Ô∏è No hay registros en la papelera para restaurar', 'warning');
                return;
            }

            try {
                let restaurados = 0;
                let errores = 0;

                for (const registro of [...registrosEliminados]) {
                    try {
                        await restoreFromTrash(registro.id, registro.originalId);
                        restaurados++;
                    } catch (error) {
                        console.error('‚ùå Error restaurando registro:', registro.id, error);
                        errores++;
                    }
                }

                mostrarMensaje(`‚úÖ ${restaurados} registros restaurados. ${errores > 0 ? `${errores} errores.` : ''}`, restaurados > 0 ? 'success' : 'warning');
                await cargarDatosYActualizarUI();

            } catch (error) {
                console.error('‚ùå Error en restauraci√≥n masiva:', error);
                mostrarMensaje('üî¥ Error en la restauraci√≥n masiva', 'error');
            }
        }

        async function vaciarPapelera() {
            if (registrosEliminados.length === 0) {
                mostrarMensaje('‚ö†Ô∏è La papelera ya est√° vac√≠a', 'warning');
                return;
            }

            try {
                let eliminados = 0;
                let errores = 0;

                for (const registro of [...registrosEliminados]) {
                    try {
                        await deleteFromTrash(registro.id);
                        eliminados++;
                    } catch (error) {
                        console.error('‚ùå Error eliminando permanentemente:', registro.id, error);
                        errores++;
                    }
                }

                mostrarMensaje(`‚úÖ ${eliminados} registros eliminados permanentemente. ${errores > 0 ? `${errores} errores.` : ''}`, eliminados > 0 ? 'success' : 'warning');
                await cargarDatosYActualizarUI();

            } catch (error) {
                console.error('‚ùå Error vaciando papelera:', error);
                mostrarMensaje('üî¥ Error vaciando la papelera', 'error');
            }
        }

        function confirmarVaciarPapelera() {
            mostrarModal(
                '‚ö†Ô∏è Confirmar Vaciar Papelera',
                `¬øEst√°s seguro de que deseas eliminar PERMANENTEMENTE todos los ${registrosEliminados.length} registros de la papelera? Esta acci√≥n NO se puede deshacer.`,
                vaciarPapelera
            );
        }

        async function limpiarBaseDatos() {
            try {
                // Limpiar memoria fallback
                memoryFallback.length = 0;
                trashFallback.length = 0;
                
                if (dbStatus === 'offline' || !db) {
                    mostrarMensaje('‚úÖ Datos de memoria limpiados (BD offline)', 'success');
                    await cargarDatosYActualizarUI();
                    return;
                }

                // Limpiar IndexedDB
                const transaction = db.transaction([STORE_NAME, TRASH_STORE_NAME], 'readwrite');
                const registrosStore = transaction.objectStore(STORE_NAME);
                const papeleraStore = transaction.objectStore(TRASH_STORE_NAME);
                
                const clearRegistros = registrosStore.clear();
                const clearPapelera = papeleraStore.clear();

                await new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;
                });

                mostrarMensaje('‚úÖ Base de datos limpiada completamente', 'success');
                await cargarDatosYActualizarUI();

            } catch (error) {
                console.error('‚ùå Error limpiando base de datos:', error);
                mostrarMensaje('üî¥ Error limpiando la base de datos', 'error');
            }
        }

        function confirmarLimpiezaTotal() {
            mostrarModal(
                '‚ö†Ô∏è PELIGRO: Confirmar Limpieza Total',
                '¬øEst√°s seguro de que deseas eliminar TODOS los datos de la aplicaci√≥n? Esto incluye todos los registros y la papelera. Esta acci√≥n NO se puede deshacer.',
                limpiarBaseDatos
            );
        }
        
        // =================================================================
        // L√ìGICA PRINCIPAL DE LA APLICACI√ìN
        // =================================================================

        window.onload = async function() {
            console.log('üöÄ Iniciando aplicaci√≥n...');
            try {
                await initDB();
                await cargarDatosYActualizarUI();
                document.getElementById('fecha').value = obtenerFechaHoyLocal();
                console.log('‚úÖ Aplicaci√≥n iniciada correctamente');
                cambiarTab(null, 'dashboard'); 
            } catch (error) {
                console.error("‚ùå Error al inicializar la aplicaci√≥n:", error);
                updateDBStatus('offline');
                mostrarMensaje('‚ö†Ô∏è Aplicaci√≥n iniciada en modo offline. Los datos se guardar√°n temporalmente.', 'warning');
                await cargarDatosYActualizarUI();
                document.getElementById('fecha').value = obtenerFechaHoyLocal();
                cambiarTab(null, 'dashboard');
            }
        };
        
        async function cargarDatosYActualizarUI() {
            console.log('üîÑ Actualizando interfaz...');
            await cargarDatos();
            cargarConsultores(); // Cargar consultores desde el sistema de usuarios
            actualizarInterfazSegunRol(); // Actualizar elementos de UI seg√∫n permisos
            actualizarDashboard();
            cargarTimeline();
            cargarClientes();
            cargarPapelera();
            console.log('‚úÖ Interfaz actualizada');
        }

        let activeTab = 'dashboard';

        function cambiarTab(event, tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            if (event) {
                event.currentTarget.classList.add('active');
            } else {
                document.querySelector(`.nav-tab[onclick*="${tabName}"]`).classList.add('active');
            }
            activeTab = tabName;
            console.log(`üìã Tab cambiado a: ${tabName}`);
            injectExportButtons(tabName);
        }

        function injectExportButtons(tabName) {
            const dashboardButtonsContainer = document.getElementById('dashboardExportButtons');
            const timelineButtonsContainer = document.getElementById('timelineExportButtons');

            if (dashboardButtonsContainer) dashboardButtonsContainer.innerHTML = '';
            if (timelineButtonsContainer) timelineButtonsContainer.innerHTML = '';

            if (tabName === 'dashboard' && dashboardButtonsContainer) {
                dashboardButtonsContainer.innerHTML = `
                    <div class="button-group">
                        <h4>üì§ Exportar Datos</h4>
                        <button class="btn-export" onclick="exportToXLSX('dashboard')">üìä Exportar XLSX</button>
                        <button class="btn-export csv" onclick="exportToCSV('dashboard')">üìÑ Exportar CSV</button>
                        <button class="btn-export pdf" onclick="exportToPDF('dashboard')">üìë Exportar PDF</button>
                    </div>
                    <div class="button-group">
                        <h4>‚òÅÔ∏è Sincronizaci√≥n</h4>
                        <button class="btn-sync" onclick="sincronizarManual('dashboard')" id="btnSyncDashboard">
                            ‚òÅÔ∏è Respaldar en GitHub
                        </button>
                    </div>
                `;
            } else if (tabName === 'timeline' && timelineButtonsContainer) {
                timelineButtonsContainer.innerHTML = `
                    <div class="button-group">
                        <h4>üì§ Exportar Datos</h4>
                        <button class="btn-export" onclick="exportToXLSX('timeline')">üìä Exportar XLSX</button>
                        <button class="btn-export csv" onclick="exportToCSV('timeline')">üìÑ Exportar CSV</button>
                        <button class="btn-export pdf" onclick="exportToPDF('timeline')">üìë Exportar PDF</button>
                    </div>
                    <div class="button-group">
                        <h4>‚òÅÔ∏è Sincronizaci√≥n</h4>
                        <button class="btn-sync" onclick="sincronizarManual('timeline')" id="btnSyncTimeline">
                            ‚òÅÔ∏è Respaldar en GitHub
                        </button>
                    </div>
                `;
            }
            console.log(`üì§ Botones de exportaci√≥n y sincronizaci√≥n inyectados para la pesta√±a: ${tabName}`);
        }

        async function sincronizarManual(tabName) {
            console.log(`‚òÅÔ∏è Iniciando sincronizaci√≥n manual desde: ${tabName}`);

            // Verificar si hay configuraci√≥n de GitHub
            const config = window.obtenerConfiguracionGitHub();
            if (!config || !config.user || !config.repo || !config.token) {
                mostrarMensaje('‚ö†Ô∏è GitHub no est√° configurado. Configure GitHub desde el panel de administraci√≥n.', 'warning');
                return;
            }

            // Obtener bot√≥n correspondiente y mostrar estado de carga
            const botonId = tabName === 'dashboard' ? 'btnSyncDashboard' : 'btnSyncTimeline';
            const boton = document.getElementById(botonId);

            if (boton) {
                const textoOriginal = boton.textContent;
                boton.classList.add('syncing');
                boton.disabled = true;
                boton.textContent = '‚è≥ Sincronizando...';
            }

            try {
                // Crear instancia de GitHubSync y ejecutar sincronizaci√≥n
                const sync = new GitHubSync();
                const resultado = await sync.sincronizacionCompleta();

                if (resultado) {
                    mostrarMensaje('‚úÖ Datos respaldados exitosamente en GitHub', 'success');
                    console.log('‚úÖ Sincronizaci√≥n manual completada');
                } else {
                    mostrarMensaje('‚ùå Error durante la sincronizaci√≥n', 'error');
                    console.log('‚ùå Error en sincronizaci√≥n manual');
                }
            } catch (error) {
                console.error('‚ùå Error en sincronizaci√≥n manual:', error);
                mostrarMensaje('‚ùå Error de conexi√≥n durante el respaldo', 'error');
            } finally {
                // Restaurar bot√≥n
                if (boton) {
                    boton.classList.remove('syncing');
                    boton.disabled = false;
                    boton.textContent = '‚òÅÔ∏è Respaldar en GitHub';
                }
            }
        }

        async function guardarRegistro() {
            console.log('üíæ Iniciando proceso de guardado...');
            clearAllValidationErrors();
            
            const form = document.getElementById('registroForm');
            if (!form.checkValidity()) {
                form.reportValidity();
                mostrarMensaje('‚ö†Ô∏è Por favor completa todos los campos requeridos', 'warning');
                return;
            }

            const formData = new FormData(form);
            const registro = {};
            for (let [key, value] of formData.entries()) {
                registro[key] = sanitizeString(value);
            }

            let hasErrors = false;

            if (!registro.fecha) {
                showValidationError('fecha', 'La fecha es requerida');
                hasErrors = true;
            }

            if (!registro.tipoInteraccion) {
                showValidationError('tipoInteraccion', 'Selecciona un tipo de interacci√≥n');
                hasErrors = true;
            }

            if (!registro.consultor) {
                showValidationError('consultor', 'Selecciona un consultor');
                hasErrors = true;
            }

            if (!registro.gerenciaReg) {
                showValidationError('gerenciaReg', 'Selecciona una gerencia');
                hasErrors = true;
            }

            if (!registro.zonaReg) {
                showValidationError('zonaReg', 'Selecciona una zona');
                hasErrors = true;
            }

            if (!registro.cliente || registro.cliente.length < 3) {
                showValidationError('cliente', 'El nombre del cliente debe tener al menos 3 caracteres');
                hasErrors = true;
            }

            if (!registro.descripcion || registro.descripcion.length < 10) {
                showValidationError('descripcion', 'La descripci√≥n debe tener al menos 10 caracteres');
                hasErrors = true;
            }

            if (registro.gerenciaReg && registro.zonaReg) {
                if (!validateGerenciaZona(registro.gerenciaReg, registro.zonaReg)) {
                    showValidationError('zonaReg', `La zona "${registro.zonaReg}" no pertenece a la gerencia "${registro.gerenciaReg}"`);
                    hasErrors = true;
                }
            }

            if (hasErrors) {
                mostrarMensaje('‚ùå Por favor corrige los errores indicados antes de guardar', 'error');
                return;
            }

            registro.gerencia = registro.gerenciaReg;
            registro.zona = registro.zonaReg;
            delete registro.gerenciaReg;
            delete registro.zonaReg;

            // Agregar informaci√≥n de qui√©n cre√≥ el registro
            const sesionActual = obtenerUsuarioActual();
            if (sesionActual) {
                registro.creadoPor = sesionActual.nombre;
                registro.usuarioCreador = sesionActual.username;
            }

            registro.fechaRegistro = obtenerFechaHoyLocal();
            registro.ultimaModificacion = new Date().toISOString();
            registro.creadoPor = sistemaAuth.obtenerUsuarioActual()?.nombre || 'Usuario';

            try {
                const id = await addRegistroToDB(registro);
                console.log('‚úÖ Registro guardado con ID:', id);
                mostrarMensaje('‚úÖ Registro guardado exitosamente');
                limpiarFormulario();
                await cargarDatosYActualizarUI();

                // Sincronizaci√≥n inmediata despu√©s de guardar
                console.log('üîÑ Iniciando sincronizaci√≥n inmediata despu√©s de guardar...');
                try {
                    const sync = new GitHubSync();
                    const resultadoSync = await sync.sincronizacionCompleta();
                    if (resultadoSync) {
                        console.log('‚úÖ Registro sincronizado con GitHub exitosamente');
                    } else {
                        console.log('‚ö†Ô∏è Sincronizaci√≥n fall√≥, se reintentar√° autom√°ticamente');
                    }
                } catch (syncError) {
                    console.error('‚ùå Error en sincronizaci√≥n inmediata:', syncError);
                    // No mostrar error al usuario, la sincronizaci√≥n autom√°tica lo reintentar√°
                }
            } catch (error) {
                console.error("‚ùå Error al guardar:", error);
                mostrarMensaje('üî¥ Hubo un error al guardar el registro. Se guard√≥ en memoria temporal.', 'warning');
                await cargarDatosYActualizarUI();
            }
        }
        
        async function cargarDatos() {
            try {
                registrosOriginales = await getAllRegistrosFromDB();
                registrosEliminados = await getAllTrashFromDB();
                console.log(`üìä Cargados ${registrosOriginales.length} registros + ${registrosEliminados.length} en papelera`);
                actualizarAutocompletado();
            } catch (error) {
                console.error("‚ùå Error al cargar datos:", error);
                registrosOriginales = [];
                registrosEliminados = [];
                mostrarMensaje('üî¥ No se pudieron cargar los registros.', 'warning');
            }
        }

        function cargarConsultores() {
            try {
                // Obtener usuarios del sistema de autenticaci√≥n
                let usuarios = {};
                if (window.sistemaAuth && typeof window.sistemaAuth.obtenerUsuarios === 'function') {
                    usuarios = window.sistemaAuth.obtenerUsuarios() || {};
                }

                // Obtener todos los usuarios activos excepto el administrador
                // Los usuarios pueden registrar servicios de cualquier consultor (excepto admin)
                const consultores = Object.entries(usuarios)
                    .filter(([username, usuario]) =>
                        username !== 'admin' &&
                        usuario.activo !== false &&
                        usuario.nombre
                    )
                    .map(([username, usuario]) => ({
                        username: username,
                        nombre: usuario.nombre
                    }))
                    .sort((a, b) => a.nombre.localeCompare(b.nombre));

                // Actualizar dropdown de nuevo registro
                const selectConsultor = document.getElementById('consultor');
                if (selectConsultor) {
                    // Limpiar opciones existentes (excepto la primera)
                    selectConsultor.innerHTML = '<option value="">Seleccionar consultor</option>';

                    // Agregar consultores
                    consultores.forEach(consultor => {
                        const option = document.createElement('option');
                        option.value = consultor.nombre;
                        option.textContent = consultor.nombre;
                        selectConsultor.appendChild(option);
                    });
                }

                // Actualizar dropdown de filtro en timeline
                const filtroConsultor = document.getElementById('filtroConsultor');
                if (filtroConsultor) {
                    // Guardar valor seleccionado actual
                    const valorActual = filtroConsultor.value;

                    // Limpiar opciones existentes (excepto la primera)
                    filtroConsultor.innerHTML = '<option value="">Todos los consultores</option>';

                    // Agregar consultores
                    consultores.forEach(consultor => {
                        const option = document.createElement('option');
                        option.value = consultor.nombre;
                        option.textContent = consultor.nombre;
                        filtroConsultor.appendChild(option);
                    });

                    // Restaurar valor seleccionado si a√∫n existe
                    if (valorActual && consultores.some(c => c.nombre === valorActual)) {
                        filtroConsultor.value = valorActual;
                    }
                }

                console.log(`üë• Cargados ${consultores.length} consultores del sistema de usuarios`);
            } catch (error) {
                console.error('‚ùå Error al cargar consultores:', error);
                // Fallback: usar consultores hardcodeados si hay un error
                cargarConsultoresFallback();
            }
        }

        function cargarConsultoresFallback() {
            console.log('‚ö†Ô∏è Usando consultores predeterminados como fallback');

            // Lista de consultores predeterminados (sin incluir administrador)
            const consultoresFallback = [
                'Guillermo de la Parra',
                'Homero Pineda',
                'Fernanda Villarreal',
                'Ana Aguilar'
            ];

            // Actualizar dropdown de nuevo registro
            const selectConsultor = document.getElementById('consultor');
            if (selectConsultor) {
                selectConsultor.innerHTML = '<option value="">Seleccionar consultor</option>';
                consultoresFallback.forEach(nombre => {
                    const option = document.createElement('option');
                    option.value = nombre;
                    option.textContent = nombre;
                    selectConsultor.appendChild(option);
                });
            }

            // Actualizar dropdown de filtro
            const filtroConsultor = document.getElementById('filtroConsultor');
            if (filtroConsultor) {
                const valorActual = filtroConsultor.value;
                filtroConsultor.innerHTML = '<option value="">Todos los consultores</option>';
                consultoresFallback.forEach(nombre => {
                    const option = document.createElement('option');
                    option.value = nombre;
                    option.textContent = nombre;
                    filtroConsultor.appendChild(option);
                });
                if (valorActual && consultoresFallback.includes(valorActual)) {
                    filtroConsultor.value = valorActual;
                }
            }
        }

        function actualizarAutocompletado() {
            try {
                const clientesUnicos = [...new Set(
                    registrosOriginales
                        .map(r => sanitizeString(safeGet(r, 'cliente')))
                        .filter(cliente => cliente.length > 0)
                )].sort();
                
                const datalist = document.getElementById('clientesDatalist');
                if (datalist) {
                    datalist.innerHTML = '';
                    clientesUnicos.forEach(cliente => {
                        const option = document.createElement('option');
                        option.value = cliente;
                        datalist.appendChild(option);
                    });
                }
                console.log(`üìù Autocompletado actualizado con ${clientesUnicos.length} clientes`);
            } catch (error) {
                console.error('‚ùå Error actualizando autocompletado:', error);
            }
        }
        
        function limpiarFormulario() {
            document.getElementById('registroForm').reset();
            document.getElementById('fecha').value = obtenerFechaHoyLocal();
            clearAllValidationErrors();
            actualizarZonasRegistro();
            console.log('üÜï Formulario limpiado');
        }

        function mostrarMensaje(texto, tipo = 'success') {
            const messagesDiv = document.getElementById('messages');
            if (!messagesDiv) return;
            
            const mensaje = document.createElement('div');
            mensaje.className = `message ${tipo}`;
            mensaje.textContent = texto;
            mensaje.style.display = 'block';
            
            messagesDiv.innerHTML = '';
            messagesDiv.appendChild(mensaje);
            
            console.log(`üì¢ Mensaje mostrado (${tipo}): ${texto}`);
            
            setTimeout(() => {
                if (mensaje.parentNode) {
                    mensaje.style.display = 'none';
                }
            }, 5000);
        }

        function actualizarZonasRegistro() {
            const gerenciaSelect = document.getElementById('gerenciaReg');
            const zonaSelect = document.getElementById('zonaReg');
            
            if (!gerenciaSelect || !zonaSelect) return;
            
            const gerenciaSeleccionada = sanitizeString(gerenciaSelect.value);
            
            zonaSelect.innerHTML = '<option value="">Primero selecciona una gerencia</option>';
            clearValidationError('zonaReg');
            
            if (gerenciaSeleccionada && zonasPorGerencia[gerenciaSeleccionada]) {
                zonaSelect.innerHTML = '<option value="">Seleccionar zona</option>';
                zonasPorGerencia[gerenciaSeleccionada].forEach(zona => {
                    const option = document.createElement('option');
                    option.value = zona;
                    option.textContent = zona;
                    zonaSelect.appendChild(option);
                });
                console.log(`üè¢ Zonas actualizadas para gerencia: ${gerenciaSeleccionada}`);
            }
        }

        function getNombreMesActual() {
            const meses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            return meses[new Date().getMonth()];
        }

        // Funciones auxiliares para manejo de fechas
        function formatearFechaLocal(fecha) {
            // Convierte una fecha a formato YYYY-MM-DD sin afectar la zona horaria
            if (!fecha) return '';

            const fechaObj = typeof fecha === 'string' ? new Date(fecha) : fecha;
            const year = fechaObj.getFullYear();
            const month = String(fechaObj.getMonth() + 1).padStart(2, '0');
            const day = String(fechaObj.getDate()).padStart(2, '0');

            return `${year}-${month}-${day}`;
        }

        function parsearFechaLocal(fechaString) {
            // Parsea una fecha YYYY-MM-DD sin conversi√≥n de zona horaria
            if (!fechaString) return null;

            const [year, month, day] = fechaString.split('-').map(Number);
            return new Date(year, month - 1, day);
        }

        function obtenerFechaHoyLocal() {
            // Obtiene la fecha de hoy en formato YYYY-MM-DD en zona horaria local
            const hoy = new Date();
            return formatearFechaLocal(hoy);
        }

        function compararFechas(fecha1, fecha2) {
            // Compara dos fechas sin considerar zona horaria
            const f1 = typeof fecha1 === 'string' ? parsearFechaLocal(fecha1) : fecha1;
            const f2 = typeof fecha2 === 'string' ? parsearFechaLocal(fecha2) : fecha2;

            if (!f1 || !f2) return 0;
            return f1.getTime() - f2.getTime();
        }

        // Funciones para control de permisos
        function obtenerUsuarioActual() {
            if (window.sistemaAuth && typeof window.sistemaAuth.obtenerSesionActual === 'function') {
                return window.sistemaAuth.obtenerSesionActual();
            }
            return null;
        }

        function esUsuarioAdmin() {
            const sesion = obtenerUsuarioActual();
            return sesion && sesion.rol === 'admin';
        }

        function filtrarRegistrosPorPermisos(registros) {
            const sesion = obtenerUsuarioActual();
            if (!sesion) {
                console.warn('‚ö†Ô∏è No hay sesi√≥n activa, no se pueden filtrar registros');
                return [];
            }

            // Los administradores ven todos los registros
            if (sesion.rol === 'admin') {
                return registros;
            }

            // Los usuarios regulares solo ven registros que ellos crearon
            const nombreUsuario = sesion.nombre;
            const usernameUsuario = sesion.username;

            return registros.filter(registro => {
                // Primero verificar con el nuevo campo 'creadoPor'
                const creadoPor = sanitizeString(safeGet(registro, 'creadoPor'));
                if (creadoPor) {
                    return creadoPor === nombreUsuario;
                }

                // Fallback para registros antiguos: usar el campo 'consultor'
                // (esto es temporal mientras migran los datos existentes)
                const consultorRegistro = sanitizeString(safeGet(registro, 'consultor'));
                return consultorRegistro === nombreUsuario;
            });
        }

        function filtrarPapeleraPorPermisos(registrosPapelera) {
            const sesion = obtenerUsuarioActual();
            if (!sesion) {
                return [];
            }

            // Los administradores ven todos los registros en papelera
            if (sesion.rol === 'admin') {
                return registrosPapelera;
            }

            // Los usuarios regulares solo ven sus propios registros eliminados
            const nombreUsuario = sesion.nombre;
            return registrosPapelera.filter(item => {
                if (item.registroEliminado) {
                    // Primero verificar con el nuevo campo 'creadoPor'
                    const creadoPor = sanitizeString(safeGet(item.registroEliminado, 'creadoPor'));
                    if (creadoPor) {
                        return creadoPor === nombreUsuario;
                    }

                    // Fallback para registros antiguos
                    const consultorRegistro = sanitizeString(safeGet(item.registroEliminado, 'consultor'));
                    return consultorRegistro === nombreUsuario;
                }
                return false;
            });
        }

        function mostrarMensajePermisos() {
            const sesion = obtenerUsuarioActual();
            if (sesion && sesion.rol !== 'admin') {
                return `üìã Mostrando solo registros creados por: ${sesion.nombre}`;
            }
            return null;
        }

        function actualizarInterfazSegunRol() {
            const esAdmin = esUsuarioAdmin();

            // Ocultar/mostrar botones de eliminaci√≥n masiva y limpieza (solo para admins)
            const elementosAdminSolo = [
                'confirmarLimpiezaTotal',
                'confirmarVaciarPapelera'
            ];

            elementosAdminSolo.forEach(id => {
                const elemento = document.querySelector(`[onclick*="${id}"]`);
                if (elemento) {
                    elemento.style.display = esAdmin ? 'inline-block' : 'none';
                }
            });

            // Mantener bot√≥n de sincronizaci√≥n del header visible para todos
            // Los usuarios ahora pueden hacer respaldo manual desde Dashboard y Timeline

            // Actualizar botones de exportaci√≥n con texto espec√≠fico del rol
            const botonesExport = document.querySelectorAll('[onclick*="export"]');
            botonesExport.forEach(boton => {
                if (!esAdmin && boton.textContent.includes('Exportar')) {
                    const textoOriginal = boton.textContent;
                    boton.title = 'Solo exportar√° sus propios registros';
                }
            });

            // El filtro de consultor ahora est√° disponible para todos los usuarios
            // Ya que pueden registrar servicios de cualquier consultor

            console.log(`üîí Interfaz actualizada para rol: ${esAdmin ? 'admin' : 'usuario'}`);
        }

        function actualizarDashboard() {
            try {
                console.log('üìä Actualizando dashboard...');

                // Aplicar filtros de permisos primero
                let registrosFiltrados = filtrarRegistrosPorPermisos(registrosOriginales);
                registrosFiltrados = registrosFiltrados.filter(r => r && typeof r === 'object');

                // Mostrar mensaje de permisos si corresponde
                const mensajePermisos = mostrarMensajePermisos();
                if (mensajePermisos) {
                    const dashboard = document.getElementById('dashboard');
                    let mensajeDiv = dashboard.querySelector('.mensaje-permisos');
                    if (!mensajeDiv) {
                        mensajeDiv = document.createElement('div');
                        mensajeDiv.className = 'mensaje-permisos';
                        mensajeDiv.style.cssText = `
                            background: #e3f2fd;
                            color: #1976d2;
                            padding: 12px 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border-left: 4px solid #2196f3;
                            font-weight: 600;
                        `;
                        dashboard.insertBefore(mensajeDiv, dashboard.firstChild);
                    }
                    mensajeDiv.textContent = mensajePermisos;
                }

                const fechaDesde = document.getElementById('dashboardFechaDesde')?.value || '';
                const fechaHasta = document.getElementById('dashboardFechaHasta')?.value || '';

                if (fechaDesde) {
                    registrosFiltrados = registrosFiltrados.filter(r => {
                        try {
                            return safeGet(r, 'fecha') >= fechaDesde;
                        } catch {
                            return false;
                        }
                    });
                }
                if (fechaHasta) {
                    registrosFiltrados = registrosFiltrados.filter(r => {
                        try {
                            return safeGet(r, 'fecha') <= fechaHasta;
                        } catch {
                            return false;
                        }
                    });
                }

                const registrosValidos = registrosFiltrados.filter(r => 
                    r && typeof r === 'object' && sanitizeString(safeGet(r, 'cliente'))
                );
                
                const totalActividades = registrosValidos.length;
                const clientesUnicos = new Set(
                    registrosValidos
                        .map(r => sanitizeString(safeGet(r, 'cliente')))
                        .filter(cliente => cliente.length > 0)
                ).size;
                
                const fechaActual = parsearFechaLocal(obtenerFechaHoyLocal());
                const mesActual = fechaActual.getMonth();
                const a√±oActual = fechaActual.getFullYear();

                const actividadMes = registrosValidos.filter(r => {
                    try {
                        const fechaReg = parsearFechaLocal(safeGet(r, 'fecha'));
                        return fechaReg.getMonth() === mesActual && fechaReg.getFullYear() === a√±oActual;
                    } catch {
                        return false;
                    }
                }).length;

                const actividadPorGerencia = {};
                registrosValidos.forEach(r => {
                    const gerencia = sanitizeString(safeGet(r, 'gerencia'));
                    if (gerencia) {
                        actividadPorGerencia[gerencia] = (actividadPorGerencia[gerencia] || 0) + 1;
                    }
                });
                
                const gerenciaMasActiva = Object.entries(actividadPorGerencia).sort(([,a], [,b]) => b - a)[0];

                const elementos = {
                    'totalActividades': totalActividades,
                    'clientesActivos': clientesUnicos,
                    'actividadMes': actividadMes,
                    'labelMesActual': `Interacciones en ${getNombreMesActual()}`,
                    'gerenciaMasActiva': gerenciaMasActiva ? gerenciaMasActiva[0] : '-',
                    'itemsEnPapelera': registrosEliminados.length
                };

                Object.entries(elementos).forEach(([id, value]) => {
                    const elemento = document.getElementById(id);
                    if (elemento) {
                        elemento.textContent = value;
                    }
                });

                generarResumenGerencias(actividadPorGerencia);
                console.log('‚úÖ Dashboard actualizado correctamente');
                
            } catch (error) {
                console.error('‚ùå Error actualizando dashboard:', error);
                mostrarMensaje('‚ö†Ô∏è Error actualizando estad√≠sticas. Algunos datos pueden no estar actualizados.', 'warning');
            }
        }

        function generarResumenGerencias(actividadPorGerencia) {
            try {
                const container = document.getElementById('resumenGerencias');
                if (!container) return;
                
                container.innerHTML = '';
                const totalRegistros = Math.max(1, registrosOriginales.length);

                Object.entries(zonasPorGerencia).forEach(([gerencia, zonas]) => {
                    const actividad = actividadPorGerencia[gerencia] || 0;
                    const porcentaje = ((actividad / totalRegistros) * 100).toFixed(1);

                    const card = document.createElement('div');
                    card.className = 'dashboard-card';
                    card.innerHTML = `
                        <h3>${sanitizeString(gerencia)}</h3>
                        <div class="stat-number">${actividad}</div>
                        <div class="stat-label">${porcentaje}% del total (${zonas.length} zonas)</div>
                    `;
                    container.appendChild(card);
                });
                console.log('üìà Resumen de gerencias generado');
            } catch (error) {
                console.error('‚ùå Error generando resumen de gerencias:', error);
            }
        }

        function filtrarTimeline() {
            try {
                // Aplicar filtros de permisos primero
                let registrosFiltrados = filtrarRegistrosPorPermisos(registrosOriginales);
                registrosFiltrados = registrosFiltrados.filter(r => r && typeof r === 'object');

                const filtroGerencia = sanitizeString(document.getElementById('filtroGerencia')?.value || '');
                const filtroTipo = sanitizeString(document.getElementById('filtroTipo')?.value || '');
                const filtroConsultor = sanitizeString(document.getElementById('filtroConsultor')?.value || '');
                const fechaDesde = document.getElementById('fechaDesde')?.value || '';
                const fechaHasta = document.getElementById('fechaHasta')?.value || '';

                if (filtroGerencia) {
                    registrosFiltrados = registrosFiltrados.filter(r => 
                        sanitizeString(safeGet(r, 'gerencia')) === filtroGerencia
                    );
                }
                if (filtroTipo) {
                    registrosFiltrados = registrosFiltrados.filter(r => 
                        sanitizeString(safeGet(r, 'tipoInteraccion')) === filtroTipo
                    );
                }
                if (filtroConsultor) {
                    registrosFiltrados = registrosFiltrados.filter(r => 
                        sanitizeString(safeGet(r, 'consultor')) === filtroConsultor
                    );
                }
                if (fechaDesde) {
                    registrosFiltrados = registrosFiltrados.filter(r => {
                        try {
                            return safeGet(r, 'fecha') >= fechaDesde;
                        } catch {
                            return false;
                        }
                    });
                }
                if (fechaHasta) {
                    registrosFiltrados = registrosFiltrados.filter(r => {
                        try {
                            return safeGet(r, 'fecha') <= fechaHasta;
                        } catch {
                            return false;
                        }
                    });
                }

                mostrarTimeline(registrosFiltrados);
                console.log(`üîç Timeline filtrado: ${registrosFiltrados.length} registros`);
            } catch (error) {
                console.error('‚ùå Error filtrando timeline:', error);
                mostrarTimeline([]);
            }
        }

        function cargarTimeline() {
            filtrarTimeline();
        }

        function mostrarTimeline(registros) {
            try {
                const container = document.getElementById('timelineContainer');
                if (!container) return;

                // Mostrar mensaje de permisos al inicio del timeline
                const mensajePermisos = mostrarMensajePermisos();
                let htmlPermisos = '';
                if (mensajePermisos) {
                    htmlPermisos = `
                        <div class="mensaje-permisos" style="
                            background: #e3f2fd;
                            color: #1976d2;
                            padding: 12px 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border-left: 4px solid #2196f3;
                            font-weight: 600;
                        ">${mensajePermisos}</div>
                    `;
                }

                const registrosValidos = registros.filter(r =>
                    r && typeof r === 'object' && sanitizeString(safeGet(r, 'cliente'))
                );

                if (registrosValidos.length === 0) {
                    container.innerHTML = htmlPermisos + '<div class="no-data">üìÖ No hay registros para mostrar.</div>';
                    return;
                }

                const registrosOrdenados = registrosValidos.sort((a, b) => {
                    try {
                        return compararFechas(safeGet(b, 'fecha'), safeGet(a, 'fecha'));
                    } catch {
                        return 0;
                    }
                });

                container.innerHTML = htmlPermisos;

                registrosOrdenados.forEach(registro => {
                    try {
                        const fechaStr = safeGet(registro, 'fecha');
                        const fecha = fechaStr ? parsearFechaLocal(fechaStr).toLocaleDateString('es-MX', { 
                            weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' 
                        }) : 'Fecha inv√°lida';
                        
                        const tipoIcons = { 
                            'visita': 'üè´', 'llamada': 'üìû', 'mensaje': 'üí¨',
                            'email': 'üìß', 'capacitacion': 'üéì', 'seguimiento': 'üìù',
                            'sesion': 'üë®‚Äçüè´', 'presentacion': 'üìã'
                        };
                        
                        const tipo = sanitizeString(safeGet(registro, 'tipoInteraccion'));
                        const cliente = sanitizeString(safeGet(registro, 'cliente')) || 'Cliente no especificado';
                        const gerencia = sanitizeString(safeGet(registro, 'gerencia')) || 'Sin gerencia';
                        const zona = sanitizeString(safeGet(registro, 'zona')) || 'Sin zona';
                        const consultor = sanitizeString(safeGet(registro, 'consultor')) || 'Sin consultor';
                        const descripcion = sanitizeString(safeGet(registro, 'descripcion')) || 'Sin descripci√≥n';
                        const creadoPor = sanitizeString(safeGet(registro, 'creadoPor')) || 'Sin informaci√≥n';

                        const item = document.createElement('div');
                        item.className = 'timeline-item';
                        item.innerHTML = `
                            <div class="timeline-date">${fecha}</div>
                            <div class="timeline-content">
                                <span class="timeline-tipo tipo-${tipo}">${tipoIcons[tipo] || 'üìã'} ${tipo.toUpperCase()}</span>
                                <div class="timeline-cliente">${cliente} - ${gerencia} (${zona})</div>
                                <div class="timeline-descripcion">
                                    <strong>Consultor:</strong> ${consultor}<br>
                                    <strong>Registrado por:</strong> ${creadoPor}<br>
                                    <strong>Descripci√≥n:</strong> ${descripcion}
                                </div>
                            </div>
                            <div class="timeline-actions">
                                <button class="btn-danger btn-small" onclick="confirmarEliminacion(${registro.id}, '${cliente.replace(/'/g, "\\'")}')">
                                    üóëÔ∏è
                                </button>
                            </div>
                        `;
                        container.appendChild(item);
                    } catch (itemError) {
                        console.error('‚ùå Error procesando item de timeline:', itemError, registro);
                    }
                });
                console.log(`üìÖ Timeline mostrado con ${registrosOrdenados.length} items`);
            } catch (error) {
                console.error('‚ùå Error mostrando timeline:', error);
                const container = document.getElementById('timelineContainer');
                if (container) {
                    container.innerHTML = '<div class="no-data">‚ùå Error cargando timeline.</div>';
                }
            }
        }

        function cargarPapelera() {
            try {
                const container = document.getElementById('papeleraContainer');
                if (!container) return;

                // Aplicar filtros de permisos a la papelera
                const registrosFiltrados = filtrarPapeleraPorPermisos(registrosEliminados);

                // Mostrar mensaje de permisos
                const mensajePermisos = mostrarMensajePermisos();
                let htmlPermisos = '';
                if (mensajePermisos) {
                    htmlPermisos = `
                        <div class="mensaje-permisos" style="
                            background: #e3f2fd;
                            color: #1976d2;
                            padding: 12px 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border-left: 4px solid #2196f3;
                            font-weight: 600;
                        ">${mensajePermisos}</div>
                    `;
                }

                if (registrosFiltrados.length === 0) {
                    container.innerHTML = htmlPermisos + '<div class="no-data">üóëÔ∏è La papelera est√° vac√≠a.</div>';
                    return;
                }

                const registrosOrdenados = registrosFiltrados.sort((a, b) => {
                    try {
                        return compararFechas(safeGet(b, 'fechaEliminacion'), safeGet(a, 'fechaEliminacion'));
                    } catch {
                        return 0;
                    }
                });

                container.innerHTML = htmlPermisos;

                registrosOrdenados.forEach(registro => {
                    try {
                        const fechaEliminacion = safeGet(registro, 'fechaEliminacion');
                        const fechaEliminacionStr = fechaEliminacion ?
                            parsearFechaLocal(fechaEliminacion).toLocaleDateString('es-MX', { 
                                year: 'numeric', month: 'short', day: 'numeric' 
                            }) : 'Fecha inv√°lida';
                        
                        const cliente = sanitizeString(safeGet(registro, 'cliente')) || 'Cliente no especificado';
                        const gerencia = sanitizeString(safeGet(registro, 'gerencia')) || 'Sin gerencia';
                        const zona = sanitizeString(safeGet(registro, 'zona')) || 'Sin zona';
                        const tipo = sanitizeString(safeGet(registro, 'tipoInteraccion')) || 'Sin tipo';
                        const descripcion = sanitizeString(safeGet(registro, 'descripcion')) || 'Sin descripci√≥n';

                        const item = document.createElement('div');
                        item.className = 'trash-item';
                        item.innerHTML = `
                            <div class="trash-date">Eliminado: ${fechaEliminacionStr}</div>
                            <div class="trash-content">
                                <div class="trash-cliente">${cliente} - ${gerencia} (${zona})</div>
                                <div class="trash-descripcion">
                                    <strong>${tipo.toUpperCase()}:</strong> ${descripcion.substring(0, 100)}${descripcion.length > 100 ? '...' : ''}
                                </div>
                            </div>
                            <div class="trash-actions">
                                <button class="btn-success btn-small" onclick="restaurarRegistro(${registro.id}, ${registro.originalId}, '${cliente.replace(/'/g, "\\'")}')">
                                    ‚Ü©Ô∏è
                                </button>
                                <button class="btn-danger btn-small" onclick="confirmarEliminacionPermanente(${registro.id}, '${cliente.replace(/'/g, "\\'")}')">
                                    ‚ùå
                                </button>
                            </div>
                        `;
                        container.appendChild(item);
                    } catch (itemError) {
                        console.error('‚ùå Error procesando item de papelera:', itemError, registro);
                    }
                });
                console.log(`üóëÔ∏è Papelera cargada con ${registrosOrdenados.length} items`);
            } catch (error) {
                console.error('‚ùå Error cargando papelera:', error);
                const container = document.getElementById('papeleraContainer');
                if (container) {
                    container.innerHTML = '<div class="no-data">‚ùå Error cargando papelera.</div>';
                }
            }
        }

        function buscarClientes() {
            try {
                const termino = sanitizeString(document.getElementById('busquedaClientes')?.value || '').toLowerCase();
                const clientesData = obtenerDatosClientes();

                if (!termino) {
                    mostrarClientes(clientesData);
                    return;
                }

                const clientesFiltrados = clientesData.filter(cliente => {
                    try {
                        return sanitizeString(cliente.nombre).toLowerCase().includes(termino) ||
                               sanitizeString(cliente.gerencia).toLowerCase().includes(termino) ||
                               sanitizeString(cliente.zona).toLowerCase().includes(termino);
                    } catch {
                        return false;
                    }
                });
                
                mostrarClientes(clientesFiltrados);
                console.log(`üîç B√∫squeda de clientes: ${clientesFiltrados.length} resultados para "${termino}"`);
            } catch (error) {
                console.error('‚ùå Error en b√∫squeda de clientes:', error);
                mostrarClientes([]);
            }
        }

        function cargarClientes() {
            const clientesData = obtenerDatosClientes();
            mostrarClientes(clientesData);
        }

        function obtenerDatosClientes() {
            try {
                const clientesMap = new Map();

                // Aplicar filtros de permisos
                const registrosFiltrados = filtrarRegistrosPorPermisos(registrosOriginales);

                registrosFiltrados.forEach(registro => {
                    if (!registro || typeof registro !== 'object') return;
                    
                    const cliente = sanitizeString(safeGet(registro, 'cliente'));
                    if (!cliente) return;
                    
                    const key = cliente;
                    if (!clientesMap.has(key)) {
                        clientesMap.set(key, {
                            nombre: cliente,
                            gerencia: sanitizeString(safeGet(registro, 'gerencia')) || 'Sin gerencia',
                            zona: sanitizeString(safeGet(registro, 'zona')) || 'Sin zona',
                            ultimaInteraccion: null,
                            stats: { visita: 0, llamada: 0, email: 0, capacitacion: 0, presentacion: 0, seguimiento: 0, renovacion: 0 }
                        });
                    }
                    
                    const clienteData = clientesMap.get(key);
                    const tipo = sanitizeString(safeGet(registro, 'tipoInteraccion'));
                    if (clienteData.stats.hasOwnProperty(tipo)) {
                        clienteData.stats[tipo]++;
                    }
                    
                    try {
                        const fechaRegistro = safeGet(registro, 'fecha');
                        if (fechaRegistro && (!clienteData.ultimaInteraccion || compararFechas(fechaRegistro, clienteData.ultimaInteraccion) > 0)) {
                            clienteData.ultimaInteraccion = fechaRegistro;
                        }
                    } catch (dateError) {
                        console.warn('‚ö†Ô∏è Error procesando fecha:', dateError);
                    }
                });
                
                const clientesArray = Array.from(clientesMap.values()).sort((a, b) => {
                    try {
                        if (!a.ultimaInteraccion) return 1;
                        if (!b.ultimaInteraccion) return -1;
                        return compararFechas(b.ultimaInteraccion, a.ultimaInteraccion);
                    } catch {
                        return 0;
                    }
                });
                
                console.log(`üë• Datos de clientes procesados: ${clientesArray.length} clientes √∫nicos`);
                return clientesArray;
            } catch (error) {
                console.error('‚ùå Error obteniendo datos de clientes:', error);
                return [];
            }
        }

        function mostrarClientes(clientes) {
            try {
                const container = document.getElementById('clientesContainer');
                if (!container) return;

                // Mostrar mensaje de permisos
                const mensajePermisos = mostrarMensajePermisos();
                let htmlPermisos = '';
                if (mensajePermisos) {
                    htmlPermisos = `
                        <div class="mensaje-permisos" style="
                            background: #e3f2fd;
                            color: #1976d2;
                            padding: 12px 20px;
                            margin-bottom: 20px;
                            border-radius: 8px;
                            border-left: 4px solid #2196f3;
                            font-weight: 600;
                        ">${mensajePermisos}</div>
                    `;
                }

                if (!clientes || clientes.length === 0) {
                    container.innerHTML = htmlPermisos + '<div class="no-data">üë• No se encontraron clientes.</div>';
                    return;
                }

                container.innerHTML = htmlPermisos;
                clientes.forEach(cliente => {
                    try {
                        const ultimaInteraccion = cliente.ultimaInteraccion ? 
                            parsearFechaLocal(cliente.ultimaInteraccion).toLocaleDateString('es-MX') : 
                            'Sin fecha';
                        
                        const totalInteracciones = Object.values(cliente.stats || {}).reduce((a, b) => (a || 0) + (b || 0), 0);
                        
                        const icons = { 
                            'visita': 'üè´', 'llamada': 'üìû', 'email': 'üìß', 
                            'capacitacion': 'üéì', 'presentacion': 'üìã', 
                            'seguimiento': 'üìù', 'renovacion': 'üîÑ' 
                        };
                        
                        const badges = Object.entries(cliente.stats || {})
                            .filter(([, cant]) => cant > 0)
                            .map(([tipo, cant]) => `<span class="stat-badge">${icons[tipo] || 'üìã'} ${cant}</span>`)
                            .join('');

                        const item = document.createElement('div');
                        item.className = 'cliente-resultado';
                        item.innerHTML = `
                            <div class="cliente-nombre">${sanitizeString(cliente.nombre)}</div>
                            <div class="cliente-info">${sanitizeString(cliente.gerencia)} - ${sanitizeString(cliente.zona)} | √öltima: ${ultimaInteraccion} | Total: ${totalInteracciones}</div>
                            <div class="cliente-stats">${badges || '<span class="stat-badge">Sin interacciones</span>'}</div>
                        `;
                        container.appendChild(item);
                    } catch (itemError) {
                        console.error('‚ùå Error procesando cliente:', itemError, cliente);
                    }
                });
                console.log(`üë• Clientes mostrados: ${clientes.length}`);
            } catch (error) {
                console.error('‚ùå Error mostrando clientes:', error);
                const container = document.getElementById('clientesContainer');
                if (container) {
                    container.innerHTML = '<div class="no-data">‚ùå Error cargando clientes.</div>';
                }
            }
        }

        // =================================================================
        // FUNCIONES DE SINCRONIZACI√ìN Y RECUPERACI√ìN
        // =================================================================
        
        async function sincronizarDatosMemoria() {
            if (dbStatus === 'offline' || !db || (memoryFallback.length === 0 && trashFallback.length === 0)) return;
            
            console.log(`üîÑ Sincronizando ${memoryFallback.length} registros + ${trashFallback.length} papelera...`);
            let sincronizados = 0;
            let errores = 0;
            
            // Sincronizar registros principales
            for (const registro of [...memoryFallback]) {
                try {
                    const registroLimpio = { ...registro };
                    delete registroLimpio.id;
                    
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.add(registroLimpio);
                    
                    await new Promise((resolve, reject) => {
                        request.onsuccess = resolve;
                        request.onerror = reject;
                    });
                    
                    const index = memoryFallback.findIndex(r => r.id === registro.id);
                    if (index > -1) memoryFallback.splice(index, 1);
                    sincronizados++;
                    
                } catch (syncError) {
                    console.error('‚ùå Error sincronizando registro:', syncError);
                    errores++;
                }
            }

            // Sincronizar papelera
            for (const registro of [...trashFallback]) {
                try {
                    const registroLimpio = { ...registro };
                    delete registroLimpio.id;
                    
                    const transaction = db.transaction([TRASH_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(TRASH_STORE_NAME);
                    const request = store.add(registroLimpio);
                    
                    await new Promise((resolve, reject) => {
                        request.onsuccess = resolve;
                        request.onerror = reject;
                    });
                    
                    const index = trashFallback.findIndex(r => r.id === registro.id);
                    if (index > -1) trashFallback.splice(index, 1);
                    sincronizados++;
                    
                } catch (syncError) {
                    console.error('‚ùå Error sincronizando papelera:', syncError);
                    errores++;
                }
            }
            
            if (sincronizados > 0) {
                console.log(`‚úÖ Sincronizados ${sincronizados} registros, ${errores} errores`);
                mostrarMensaje(`‚úÖ ${sincronizados} registros sincronizados con la base de datos`, 'success');
                await cargarDatosYActualizarUI();
            }
        }

        // Verificar peri√≥dicamente el estado de la conexi√≥n
        setInterval(async () => {
            if (dbStatus === 'offline') {
                try {
                    await initDB();
                    if (dbStatus === 'online') {
                        console.log('üîÑ Reconectado a IndexedDB');
                        await sincronizarDatosMemoria();
                    }
                } catch (reconnectError) {
                    console.log('üî¥ A√∫n sin conexi√≥n a BD');
                }
            }
        }, 30000);

        document.addEventListener('visibilitychange', async () => {
            if (!document.hidden && dbStatus === 'online' && (memoryFallback.length > 0 || trashFallback.length > 0)) {
                await sincronizarDatosMemoria();
            }
        });

        // =================================================================
        // MANEJO DE ERRORES GLOBALES
        // =================================================================
        
        window.addEventListener('error', (event) => {
            console.error('‚ùå Error global capturado:', event.error);
            mostrarMensaje('‚ö†Ô∏è Se detect√≥ un error. La aplicaci√≥n sigue funcionando en modo seguro.', 'warning');
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('‚ùå Promise rechazada no manejada:', event.reason);
            mostrarMensaje('‚ö†Ô∏è Error de proceso. Los datos se guardan localmente.', 'warning');
            event.preventDefault();
        });

        // =================================================================
        // VALIDACI√ìN ADICIONAL EN EVENTOS DE FORMULARIO
        // =================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            const form = document.getElementById('registroForm');
            if (form) {
                form.addEventListener('input', (event) => {
                    const field = event.target;
                    if (field.name) {
                        clearValidationError(field.name);
                    }
                });

                const gerenciaSelect = document.getElementById('gerenciaReg');
                const zonaSelect = document.getElementById('zonaReg');
                
                if (zonaSelect) {
                    zonaSelect.addEventListener('change', () => {
                        const gerencia = gerenciaSelect?.value;
                        const zona = zonaSelect.value;
                        
                        if (gerencia && zona && !validateGerenciaZona(gerencia, zona)) {
                            showValidationError('zonaReg', `La zona "${zona}" no pertenece a la gerencia "${gerencia}"`);
                        } else {
                            clearValidationError('zonaReg');
                        }
                    });
                }
            }

            // Cerrar modal al hacer clic fuera
            window.onclick = function(event) {
                const modal = document.getElementById('confirmModal');
                if (event.target === modal) {
                    cerrarModal();
                }
            }
        });

        // =================================================================
        // FUNCIONES DE EXPORTACI√ìN (MISMAS QUE ANTES)
        // =================================================================
        
        function getEstadisticasBasicas() {
            try {
                const stats = {
                    totalRegistros: registrosOriginales.length,
                    clientesUnicos: new Set(registrosOriginales.map(r => sanitizeString(safeGet(r, 'cliente'))).filter(Boolean)).size,
                    gerenciasActivas: new Set(registrosOriginales.map(r => sanitizeString(safeGet(r, 'gerencia'))).filter(Boolean)).size,
                    consultoresActivos: new Set(registrosOriginales.map(r => sanitizeString(safeGet(r, 'consultor'))).filter(Boolean)).size,
                    tiposInteraccion: new Set(registrosOriginales.map(r => sanitizeString(safeGet(r, 'tipoInteraccion'))).filter(Boolean)).size,
                    registrosMemoria: memoryFallback.length,
                    registrosPapelera: registrosEliminados.length,
                    estadoBD: dbStatus
                };
                return stats;
            } catch (error) {
                console.error('‚ùå Error obteniendo estad√≠sticas:', error);
                return null;
            }
        }

        function getFilteredDataForExport(tabName) {
            // Aplicar filtros de permisos primero
            let filteredData = filtrarRegistrosPorPermisos(registrosOriginales);

            if (tabName === 'timeline') {
                const filtroGerencia = sanitizeString(document.getElementById('filtroGerencia')?.value || '');
                const filtroTipo = sanitizeString(document.getElementById('filtroTipo')?.value || '');
                const filtroConsultor = sanitizeString(document.getElementById('filtroConsultor')?.value || '');
                const fechaDesde = document.getElementById('fechaDesde')?.value || '';
                const fechaHasta = document.getElementById('fechaHasta')?.value || '';

                if (filtroGerencia) {
                    filteredData = filteredData.filter(r => 
                        sanitizeString(safeGet(r, 'gerencia')) === filtroGerencia
                    );
                }
                if (filtroTipo) {
                    filteredData = filteredData.filter(r => 
                        sanitizeString(safeGet(r, 'tipoInteraccion')) === filtroTipo
                    );
                }
                if (filtroConsultor) {
                    filteredData = filteredData.filter(r => 
                        sanitizeString(safeGet(r, 'consultor')) === filtroConsultor
                    );
                }
                if (fechaDesde) {
                    filteredData = filteredData.filter(r => {
                        try {
                            return safeGet(r, 'fecha') >= fechaDesde;
                        } catch {
                            return false;
                        }
                    });
                }
                if (fechaHasta) {
                    filteredData = filteredData.filter(r => {
                        try {
                            return safeGet(r, 'fecha') <= fechaHasta;
                        } catch {
                            return false;
                        }
                    });
                }
            } else if (tabName === 'dashboard') {
                const dashboardFechaDesde = document.getElementById('dashboardFechaDesde')?.value || '';
                const dashboardFechaHasta = document.getElementById('dashboardFechaHasta')?.value || '';

                if (dashboardFechaDesde) {
                    filteredData = filteredData.filter(r => {
                        try {
                            return safeGet(r, 'fecha') >= dashboardFechaDesde;
                        } catch {
                            return false;
                        }
                    });
                }
                if (dashboardFechaHasta) {
                    filteredData = filteredData.filter(r => {
                        try {
                            return safeGet(r, 'fecha') <= dashboardFechaHasta;
                        } catch {
                            return false;
                        }
                    });
                }
            }
            
            return filteredData.filter(r => r && typeof r === 'object' && sanitizeString(safeGet(r, 'cliente')));
        }

        function exportToXLSX(tabName) {
            console.log(`üì§ Iniciando exportaci√≥n XLSX para: ${tabName}`);
            const dataToExport = getFilteredDataForExport(tabName);

            if (dataToExport.length === 0) {
                mostrarMensaje('‚ö†Ô∏è No hay datos para exportar con los filtros actuales.', 'warning');
                return;
            }

            const wb = XLSX.utils.book_new();
            wb.Props = {
                Title: "Seguimiento de Clientes Dayton",
                Subject: "Exportaci√≥n de datos",
                Author: "Sistema de Seguimiento UDP",
                CreatedDate: new Date()
            };
            const today = obtenerFechaHoyLocal();
            let fileName = `dayton_${tabName}_${today}.xlsx`;

            if (tabName === 'dashboard') {
                const stats = getEstadisticasBasicas();
                const statsData = [
                    ["Estad√≠stica", "Valor"],
                    ["Total de Interacciones", stats.totalRegistros],
                    ["Clientes √önicos", stats.clientesUnicos],
                    ["Gerencias Activas", stats.gerenciasActivas],
                    ["Consultores Activos", stats.consultoresActivos],
                    ["Tipos de Interacci√≥n √önicos", stats.tiposInteraccion],
                    ["Registros en Papelera", stats.registrosPapelera]
                ];
                const ws1 = XLSX.utils.aoa_to_sheet(statsData);
                XLSX.utils.book_append_sheet(wb, ws1, "Estad√≠sticas Generales");

                const actividadPorGerencia = {};
                dataToExport.forEach(r => {
                    const gerencia = sanitizeString(safeGet(r, 'gerencia'));
                    if (gerencia) {
                        actividadPorGerencia[gerencia] = (actividadPorGerencia[gerencia] || 0) + 1;
                    }
                });
                const resumenGerenciasData = [
                    ["Gerencia", "Total Interacciones", "% del Total"]
                ];
                const totalRegistrosFiltrados = Math.max(1, dataToExport.length);
                Object.entries(zonasPorGerencia).forEach(([gerencia, zonas]) => {
                    const actividad = actividadPorGerencia[gerencia] || 0;
                    const porcentaje = ((actividad / totalRegistrosFiltrados) * 100).toFixed(1) + '%';
                    resumenGerenciasData.push([gerencia, actividad, porcentaje]);
                });
                const ws2 = XLSX.utils.aoa_to_sheet(resumenGerenciasData);
                XLSX.utils.book_append_sheet(wb, ws2, "Resumen por Gerencia");

                const detailedHeaders = [
                    "Fecha", "Tipo de Interacci√≥n", "Cliente", "Gerencia", "Zona Comercial", "Consultor/a", "Descripci√≥n"
                ].map(header => prepareTextForPDF(header));
                const detailedData = dataToExport.map(r => [
                    prepareTextForPDF(safeGet(r, 'fecha')),
                    prepareTextForPDF(safeGet(r, 'tipoInteraccion')),
                    prepareTextForPDF(safeGet(r, 'cliente')),
                    prepareTextForPDF(safeGet(r, 'gerencia')),
                    prepareTextForPDF(safeGet(r, 'zona')),
                    prepareTextForPDF(safeGet(r, 'consultor')),
                    prepareTextForPDF(safeGet(r, 'descripcion'))
                ]);
                const ws3 = XLSX.utils.aoa_to_sheet([detailedHeaders, ...detailedData]);
                XLSX.utils.book_append_sheet(wb, ws3, "Registros Detallados");

            } else if (tabName === 'timeline') {
                const headers = [
                    "Fecha", "Tipo de Interacci√≥n", "Cliente", "Gerencia", "Zona Comercial", "Consultor/a", "Descripci√≥n"
                ].map(header => prepareTextForPDF(header));
                const data = dataToExport.map(r => [
                    safeGet(r, 'fecha'),
                    safeGet(r, 'tipoInteraccion'),
                    safeGet(r, 'cliente'),
                    safeGet(r, 'gerencia'),
                    safeGet(r, 'zona'),
                    safeGet(r, 'consultor'),
                    safeGet(r, 'descripcion')
                ]);
                const ws = XLSX.utils.aoa_to_sheet([headers, ...data]);
                XLSX.utils.book_append_sheet(wb, ws, "Registros Timeline");
            }

            XLSX.writeFile(wb, fileName, {
                bookType: 'xlsx',
                type: 'binary',
                compression: true
            });
            mostrarMensaje(`‚úÖ Archivo ${fileName} generado exitosamente.`, 'success');
            console.log('‚úÖ XLSX exportado');
        }

        function exportToCSV(tabName) {
            console.log(`üì§ Iniciando exportaci√≥n CSV para: ${tabName}`);
            const dataToExport = getFilteredDataForExport(tabName);

            if (dataToExport.length === 0) {
                mostrarMensaje('‚ö†Ô∏è No hay datos para exportar con los filtros actuales.', 'warning');
                return;
            }

            let headers = [];
            let rows = [];

            if (tabName === 'dashboard') {
                headers = [
                    "Fecha", "Tipo de Interacci√≥n", "Cliente", "Gerencia", "Zona Comercial", "Consultor/a", "Descripci√≥n"
                ];
                rows = dataToExport.map(r => [
                    safeGet(r, 'fecha'),
                    safeGet(r, 'tipoInteraccion'),
                    safeGet(r, 'cliente'),
                    safeGet(r, 'gerencia'),
                    safeGet(r, 'zona'),
                    safeGet(r, 'consultor'),
                    safeGet(r, 'descripcion')
                ]);
            } else if (tabName === 'timeline') {
                headers = [
                    "Fecha", "Tipo de Interacci√≥n", "Cliente", "Gerencia", "Zona Comercial", "Consultor/a", "Descripci√≥n"
                ];
                rows = dataToExport.map(r => [
                    safeGet(r, 'fecha'),
                    safeGet(r, 'tipoInteraccion'),
                    safeGet(r, 'cliente'),
                    safeGet(r, 'gerencia'),
                    safeGet(r, 'zona'),
                    safeGet(r, 'consultor'),
                    safeGet(r, 'descripcion')
                ]);
            }

            const csvContent = "\uFEFF" + [
                headers.map(h => `"${h.replace(/"/g, '""')}"`).join(','),
                ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const today = obtenerFechaHoyLocal();
            const fileName = `dayton_${tabName}_${today}.csv`;

            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                mostrarMensaje(`‚úÖ Archivo ${fileName} generado exitosamente.`, 'success');
                console.log('‚úÖ CSV exportado');
            } else {
                mostrarMensaje('üî¥ Tu navegador no soporta la descarga directa de archivos.', 'error');
                console.error('‚ùå Descarga directa de CSV no soportada.');
            }
        }

        function exportToPDF(tabName) {
            console.log(`üì§ Iniciando exportaci√≥n PDF para: ${tabName}`);
            const { jsPDF } = window.jspdf;

            // Configurar jsPDF con soporte mejorado para UTF-8
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                putOnlyUsedFonts: true,
                floatPrecision: 16
            });

            const today = obtenerFechaHoyLocal();
            let fileName = `dayton_${tabName}_${today}.pdf`;

            // Intentar configurar fuente con soporte UTF-8
            try {
                // Configurar documento para UTF-8
                doc.setFont("helvetica");
                doc.setCharSpace(0);
                doc.setFontSize(12);
            } catch (error) {
                console.warn('Error configurando fuente:', error);
            }

            // Nueva estrategia: usar c√≥digos de caracteres espec√≠ficos para caracteres especiales
            function processTextForPDF(text) {
                if (!text) return '';

                // Convertir a string y procesar caracteres especiales
                let processedText = String(text);

                // Mapeo de caracteres especiales para jsPDF
                const charMap = {
                    '√°': '\u00E1', '√©': '\u00E9', '√≠': '\u00ED', '√≥': '\u00F3', '√∫': '\u00FA',
                    '√Å': '\u00C1', '√â': '\u00C9', '√ç': '\u00CD', '√ì': '\u00D3', '√ö': '\u00DA',
                    '√±': '\u00F1', '√ë': '\u00D1', '√º': '\u00FC', '√ú': '\u00DC',
                    '¬ø': '\u00BF', '¬°': '\u00A1'
                };

                // Intentar usar c√≥digos Unicode expl√≠citos
                for (const [char, code] of Object.entries(charMap)) {
                    processedText = processedText.replace(new RegExp(char, 'g'), code);
                }

                // Limpiar solo caracteres realmente problem√°ticos
                processedText = processedText
                    .replace(/[""]/g, '"')
                    .replace(/['']/g, "'")
                    .replace(/‚Äì/g, '-')
                    .replace(/‚Äî/g, '-')
                    .replace(/‚Ä¶/g, '...')
                    .replace(/\u00A0/g, ' ');

                return processedText;
            }

            // M√©todo de fallback: crear PDF desde HTML si los caracteres fallan
            function createPDFFromHTML(htmlContent, fileName) {
                // Crear un elemento temporal con el contenido
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                tempDiv.style.cssText = `
                    position: absolute;
                    left: -9999px;
                    top: -9999px;
                    width: 210mm;
                    padding: 20px;
                    font-family: Arial, sans-serif;
                    font-size: 12px;
                    line-height: 1.4;
                    color: #333;
                `;
                document.body.appendChild(tempDiv);

                // Usar html2canvas si est√° disponible (como fallback futuro)
                if (window.html2canvas) {
                    return html2canvas(tempDiv).then(canvas => {
                        document.body.removeChild(tempDiv);
                        const imgData = canvas.toDataURL('image/png');
                        const pdf = new jsPDF();
                        const imgWidth = 210;
                        const imgHeight = canvas.height * imgWidth / canvas.width;
                        pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
                        pdf.save(fileName);
                    });
                }

                document.body.removeChild(tempDiv);
                return Promise.reject('html2canvas no disponible');
            }

            // Alias para compatibilidad
            const prepareTextForPDF = processTextForPDF;

            doc.setFontSize(18);
            doc.setTextColor(44, 62, 80);
            doc.text(prepareTextForPDF("University of Dayton Publishing"), doc.internal.pageSize.getWidth() / 2, 20, { align: 'center' });
            doc.setFontSize(12);
            doc.setTextColor(127, 140, 141);
            doc.text(prepareTextForPDF("Sistema de Seguimiento de Clientes"), doc.internal.pageSize.getWidth() / 2, 28, { align: 'center' });
            doc.line(10, 35, doc.internal.pageSize.getWidth() - 10, 35);

            let yOffset = 45;

            if (tabName === 'dashboard') {
                const stats = getEstadisticasBasicas();
                const dataToExport = getFilteredDataForExport(tabName);

                if (dataToExport.length === 0) {
                    mostrarMensaje('‚ö†Ô∏è No hay datos para exportar con los filtros actuales.', 'warning');
                    return;
                }

                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text(prepareTextForPDF("Estad√≠sticas Generales"), 14, yOffset);
                yOffset += 10;

                const statsTableData = [
                    ["Total de Interacciones", stats.totalRegistros],
                    ["Clientes √önicos", stats.clientesUnicos],
                    ["Gerencias Activas", stats.gerenciasActivas],
                    ["Consultores Activos", stats.consultoresActivos],
                    ["Tipos de Interacci√≥n √önicos", stats.tiposInteraccion],
                    ["Registros en Papelera", stats.registrosPapelera]
                ].map(row => [prepareTextForPDF(row[0]), row[1]]);
                doc.autoTable({
                    startY: yOffset,
                    head: [[prepareTextForPDF('Estad√≠stica'), prepareTextForPDF('Valor')]],
                    body: statsTableData,
                    theme: 'striped',
                    styles: { fontSize: 10, cellPadding: 2, overflow: 'linebreak' },
                    headStyles: { fillColor: [102, 126, 234], textColor: 255, fontStyle: 'bold' },
                    margin: { left: 10, right: 10 },
                    didDrawPage: function (data) {
                        doc.setFontSize(10);
                        doc.setTextColor(150);
                        doc.text(`P√°gina ${doc.internal.getNumberOfPages()}`, doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, { align: 'right' });
                    }
                });
                yOffset = doc.autoTable.previous.finalY + 15;

                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text("Resumen por Gerencia", 14, yOffset);
                yOffset += 10;

                const actividadPorGerencia = {};
                dataToExport.forEach(r => {
                    const gerencia = sanitizeString(safeGet(r, 'gerencia'));
                    if (gerencia) {
                        actividadPorGerencia[gerencia] = (actividadPorGerencia[gerencia] || 0) + 1;
                    }
                });
                const resumenGerenciasTableData = [];
                const totalRegistrosFiltrados = Math.max(1, dataToExport.length);
                Object.entries(zonasPorGerencia).forEach(([gerencia, zonas]) => {
                    const actividad = actividadPorGerencia[gerencia] || 0;
                    const porcentaje = ((actividad / totalRegistrosFiltrados) * 100).toFixed(1) + '%';
                    resumenGerenciasTableData.push([prepareTextForPDF(gerencia), actividad, porcentaje]);
                });

                doc.autoTable({
                    startY: yOffset,
                    head: [[prepareTextForPDF('Gerencia'), prepareTextForPDF('Total Interacciones'), prepareTextForPDF('% del Total')]],
                    body: resumenGerenciasTableData,
                    theme: 'striped',
                    styles: { fontSize: 10, cellPadding: 2, overflow: 'linebreak' },
                    headStyles: { fillColor: [102, 126, 234], textColor: 255, fontStyle: 'bold' },
                    margin: { left: 10, right: 10 },
                    didDrawPage: function (data) {
                        doc.setFontSize(10);
                        doc.setTextColor(150);
                        doc.text(`P√°gina ${doc.internal.getNumberOfPages()}`, doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, { align: 'right' });
                    }
                });
                yOffset = doc.autoTable.previous.finalY + 15;

                doc.addPage();
                yOffset = 45;
                doc.setFontSize(18);
                doc.setTextColor(44, 62, 80);
                doc.text("University of Dayton Publishing", doc.internal.pageSize.getWidth() / 2, 20, { align: 'center' });
                doc.setFontSize(12);
                doc.setTextColor(127, 140, 141);
                doc.text("Sistema de Seguimiento de Clientes", doc.internal.pageSize.getWidth() / 2, 28, { align: 'center' });
                doc.line(10, 35, doc.internal.pageSize.getWidth() - 10, 35);
                
                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text("Registros Detallados", 14, yOffset);
                yOffset += 10;

                const detailedHeaders = [
                    "Fecha", "Tipo", "Cliente", "Gerencia", "Zona", "Consultor", "Descripci√≥n"
                ];
                const detailedData = dataToExport.map(r => [
                    prepareTextForPDF(safeGet(r, 'fecha')),
                    prepareTextForPDF(safeGet(r, 'tipoInteraccion')),
                    prepareTextForPDF(safeGet(r, 'cliente')),
                    prepareTextForPDF(safeGet(r, 'gerencia')),
                    prepareTextForPDF(safeGet(r, 'zona')),
                    prepareTextForPDF(safeGet(r, 'consultor')),
                    prepareTextForPDF(safeGet(r, 'descripcion'))
                ]);

                doc.autoTable({
                    startY: yOffset,
                    head: [detailedHeaders],
                    body: detailedData,
                    theme: 'striped',
                    styles: { fontSize: 8, cellPadding: 1, overflow: 'linebreak' },
                    headStyles: { fillColor: [102, 126, 234], textColor: 255, fontStyle: 'bold' },
                    columnStyles: {
                        0: { cellWidth: 18 },
                        1: { cellWidth: 20 },
                        2: { cellWidth: 30 },
                        3: { cellWidth: 20 },
                        4: { cellWidth: 20 },
                        5: { cellWidth: 25 },
                        6: { cellWidth: 'auto' }
                    },
                    margin: { left: 10, right: 10 },
                    didDrawPage: function (data) {
                        doc.setFontSize(10);
                        doc.setTextColor(150);
                        doc.text(`P√°gina ${doc.internal.getNumberOfPages()}`, doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, { align: 'right' });
                    }
                });

            } else if (tabName === 'timeline') {
                const dataToExport = getFilteredDataForExport(tabName);

                if (dataToExport.length === 0) {
                    mostrarMensaje('‚ö†Ô∏è No hay datos para exportar con los filtros actuales.', 'warning');
                    return;
                }

                doc.setFontSize(16);
                doc.setTextColor(44, 62, 80);
                doc.text("Timeline de Interacciones", 14, yOffset);
                yOffset += 10;

                const headers = [
                    "Fecha", "Tipo", "Cliente", "Gerencia", "Zona", "Consultor", "Descripci√≥n"
                ];
                const rows = dataToExport.map(r => [
                    prepareTextForPDF(safeGet(r, 'fecha')),
                    prepareTextForPDF(safeGet(r, 'tipoInteraccion')),
                    prepareTextForPDF(safeGet(r, 'cliente')),
                    prepareTextForPDF(safeGet(r, 'gerencia')),
                    prepareTextForPDF(safeGet(r, 'zona')),
                    prepareTextForPDF(safeGet(r, 'consultor')),
                    prepareTextForPDF(safeGet(r, 'descripcion'))
                ]);

                doc.autoTable({
                    startY: yOffset,
                    head: [headers],
                    body: rows,
                    theme: 'striped',
                    styles: { fontSize: 8, cellPadding: 1, overflow: 'linebreak' },
                    headStyles: { fillColor: [102, 126, 234], textColor: 255, fontStyle: 'bold' },
                    columnStyles: {
                        0: { cellWidth: 18 },
                        1: { cellWidth: 20 },
                        2: { cellWidth: 30 },
                        3: { cellWidth: 20 },
                        4: { cellWidth: 20 },
                        5: { cellWidth: 25 },
                        6: { cellWidth: 'auto' }
                    },
                    margin: { left: 10, right: 10 },
                    didDrawPage: function (data) {
                        doc.setFontSize(10);
                        doc.setTextColor(150);
                        doc.text(`P√°gina ${doc.internal.getNumberOfPages()}`, doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, { align: 'right' });
                    }
                });
            }

            doc.save(fileName);
            mostrarMensaje(`‚úÖ Archivo ${fileName} generado exitosamente.`, 'success');
            console.log('‚úÖ PDF exportado');
        }

        // =================================================================
        // FUNCIONES DE UTILIDAD Y DEBUG
        // =================================================================
        
        function exportarDatos() {
            try {
                const dataStr = JSON.stringify(registrosOriginales, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = `seguimiento_clientes_${obtenerFechaHoyLocal()}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                mostrarMensaje('‚úÖ Datos exportados correctamente', 'success');
                console.log('üì§ Datos exportados');
            } catch (error) {
                console.error('‚ùå Error exportando datos:', error);
                mostrarMensaje('üî¥ Error al exportar los datos', 'error');
            }
        }

        // Funciones de debugging disponibles en consola
        window.debugDayton = {
            stats: getEstadisticasBasicas,
            exportar: exportarDatos,
            sincronizar: sincronizarDatosMemoria,
            limpiarMemoria: () => {
                memoryFallback.length = 0;
                trashFallback.length = 0;
                console.log('üßπ Memoria fallback limpiada');
            },
            mostrarDatos: () => {
                console.log('üìä Registros originales:', registrosOriginales);
                console.log('üíæ Memoria fallback:', memoryFallback);
                console.log('üóëÔ∏è Papelera:', registrosEliminados);
                console.log('üîß Estad√≠sticas:', getEstadisticasBasicas());
            },
            // Nuevas funciones de debug para eliminaci√≥n
            eliminarTodo: () => {
                console.warn('‚ö†Ô∏è PELIGRO: Esta funci√≥n eliminar√° TODOS los datos');
                if (confirm('¬øEst√°s SEGURO de que quieres eliminar todos los datos?')) {
                    limpiarBaseDatos();
                }
            },
            restaurarTodoPapelera: () => {
                console.log('‚Ü©Ô∏è Restaurando todos los items de papelera...');
                restaurarTodos();
            },
            vaciarPapeleraDebug: () => {
                console.warn('‚ö†Ô∏è PELIGRO: Esta funci√≥n vaciar√° la papelera permanentemente');
                if (confirm('¬øEst√°s SEGURO de que quieres vaciar la papelera?')) {
                    vaciarPapelera();
                }
            }
        };

        // Hacer funciones disponibles globalmente
        window.cargarConsultores = cargarConsultores;
        window.sincronizarManual = sincronizarManual;

        console.log('üîß Funciones de debug disponibles en window.debugDayton');
        // Registrar Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./service-worker.js')
                .then(registration => {
                    console.log('‚úÖ Service Worker registrado:', registration);
                })
                .catch(error => {
                    console.error('‚ùå Error registrando Service Worker:', error);
                });
        }

        console.log('üìã Sistema de seguimiento de clientes Dayton con autenticaci√≥n inicializado correctamente');
        console.log('üÜï NUEVAS CARACTER√çSTICAS:');
        console.log('   ‚Ä¢ Sistema de autenticaci√≥n con roles');
        console.log('   ‚Ä¢ Panel de administraci√≥n de usuarios');
        console.log('   ‚Ä¢ Sincronizaci√≥n con GitHub');
        console.log('   ‚Ä¢ Dropdown de consultores din√°mico desde usuarios del sistema');
        console.log('   ‚Ä¢ Eliminaci√≥n individual con bot√≥n üóëÔ∏è en cada registro');
        console.log('   ‚Ä¢ Eliminaci√≥n masiva de registros filtrados');
        console.log('   ‚Ä¢ Papelera de reciclaje con funciones de restaurar/eliminar permanentemente');
        console.log('   ‚Ä¢ Limpieza total de la base de datos');
        console.log('   ‚Ä¢ Estad√≠sticas de papelera en el dashboard');
    </script>
</body>
</html>
